{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SilverLingua","text":"<p>A type-safe framework for building AI agents using atomic design patterns and hierarchical memory.</p>"},{"location":"#why-silverlingua","title":"Why SilverLingua?","text":"<p>Unlike LangChain's complex chains and callbacks, SilverLingua provides:</p> <ul> <li>Type Safety: Every component is a Pydantic model - no more runtime surprises</li> <li>Atomic Design: Build complex agents from simple, composable pieces</li> <li>Clean Interfaces: Consistent patterns across the entire framework</li> <li>Provider Agnostic: Switch between LLMs without changing your agent logic</li> </ul>"},{"location":"#core-architecture","title":"Core Architecture","text":""},{"location":"#memory-system","title":"Memory System","text":"<pre><code># Base memory unit - simple and type-safe\nclass Memory(BaseModel):\n    content: str\n\n# Role-aware memory with validation\nclass Notion(Memory):\n    role: str\n    persistent: bool = False\n</code></pre>"},{"location":"#idearium-extensible-memory-management","title":"Idearium - Extensible Memory Management","text":"<pre><code># LangChain's ConversationBufferMemory - Complex inheritance, mixed concerns\nclass ConversationBufferMemory(BaseChatMemory):\n    return_messages: bool = False\n    human_prefix: str = \"Human\"\n    ai_prefix: str = \"AI\"\n    memory_key: str = \"history\"\n\n    @property\n    def buffer(self) -&gt; Any:  # Type hints lost\n        if self.return_messages: ...\n        else: ...\n\n# SilverLingua's Idearium - Clean, composable, token-aware\nclass Idearium(BaseModel):\n    tokenizer: Tokenizer\n    max_tokens: int\n    notions: List[Notion]\n    persistent_indices: set\n\n    def _trim(self):\n        \"\"\"Extension point for custom trimming strategies\"\"\"\n        while self.total_tokens &gt; self.max_tokens:\n            # Default implementation\n            pass\n\n# Easy to extend for different memory strategies\nclass SummarizingIdearium(Idearium):\n    def _trim(self):\n        \"\"\"Custom trimming with automatic summarization\"\"\"\n        if self.total_tokens &gt; self.max_tokens:\n            # Summarize oldest non-persistent memories\n            summary = self.summarize_notions(self.get_trim_candidates())\n            self.replace_with_summary(summary)\n\nclass RAGIdearium(Idearium):\n    def __init__(self, vector_store, **kwargs):\n        super().__init__(**kwargs)\n        self.vector_store = vector_store\n\n    def _trim(self):\n        \"\"\"Store trimmed memories in vector store\"\"\"\n        for notion in self.get_trim_candidates():\n            self.vector_store.add(notion.content)\n        super()._trim()\n\n    def get_context(self, query: str) -&gt; List[Notion]:\n        \"\"\"Retrieve relevant memories\"\"\"\n        return self.vector_store.similarity_search(query)\n</code></pre>"},{"location":"#provider-integration","title":"Provider Integration","text":"<pre><code># Clean model interface\nclass OpenAIModel:\n    def generate(self, prompt: str) -&gt; str:\n        # OpenAI-specific implementation\n        pass\n\n# Consistent agent pattern\nclass OpenAIChatAgent(Agent):\n    def _bind_tools(self) -&gt; None:\n        # Automatic OpenAI function calling format\n        self.model.completion_params.tools = [\n            {\"type\": \"function\", \"function\": tool.description}\n            for tool in self.tools\n        ]\n</code></pre>"},{"location":"#why-this-matters","title":"Why This Matters","text":""},{"location":"#langchain-memory","title":"LangChain Memory","text":"<pre><code># Complex setup, multiple inheritance, mixed concerns\nmemory = ConversationBufferMemory(\n    memory_key=\"chat_history\",\n    return_messages=True,\n    output_key=\"output\",\n    input_key=\"input\",\n)\nchain = LLMChain(\n    llm=llm,\n    memory=memory,\n    prompt=prompt,\n    verbose=True\n)\n</code></pre>"},{"location":"#silverlingua-memory","title":"SilverLingua Memory","text":"<pre><code># Clean, composable, type-safe\nidearium = RAGIdearium(\n    vector_store=vector_store,\n    tokenizer=tokenizer,\n    max_tokens=4096\n)\n\n# Easy to use\nidearium.append(Notion(\"Important fact\", persistent=True))\nidearium.extend(new_memories)  # Auto-manages tokens\n\n# Automatic context management\nrelevant_context = idearium.get_context(\"query\")\n</code></pre>"},{"location":"#key-benefits","title":"Key Benefits","text":"<ol> <li> <p>Extensible Memory</p> </li> <li> <p>Clear extension points (<code>_trim</code>, etc.)</p> </li> <li>Type-safe customization</li> <li> <p>Easy integration with external systems</p> </li> <li> <p>Token Management</p> </li> <li> <p>Automatic token tracking</p> </li> <li>Smart memory trimming</li> <li> <p>Persistent memory support</p> </li> <li> <p>Clean Architecture</p> </li> <li>Single responsibility principle</li> <li>Consistent interfaces</li> <li>Type-safe operations</li> </ol>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Installation</li> <li>API Reference</li> <li>Examples</li> </ul>"},{"location":"design-principles/","title":"Design Principles","text":"<p>SilverLingua follows a biological-inspired architecture that organizes components into distinct layers of complexity and responsibility. This design emerged from the need for a lightweight, type-safe, and intuitive framework for building AI agents without unnecessary complexity or boilerplate.</p>"},{"location":"design-principles/#core-philosophy","title":"Core Philosophy","text":"<p>SilverLingua was created in response to the challenges of working with existing frameworks like LangChain, which often introduce unnecessary complexity and tight coupling. Our core principles are:</p> <ul> <li>Lightweight: Every component serves a clear purpose with minimal overhead</li> <li>Type-safe: Leveraging Pydantic for runtime type validation and data modeling, ensuring reliable and maintainable code with excellent IDE support</li> <li>Easily extensible: Universal interfaces make it simple to add or modify functionality</li> <li>Intuitive: Clear action flows and lifecycle methods that are easy to understand</li> <li>Surgical modification: Ability to modify specific behaviors without affecting others</li> <li>Minimal boilerplate: Focus on productive code, not repetitive setup</li> </ul>"},{"location":"design-principles/#core-architectural-layers","title":"Core Architectural Layers","text":""},{"location":"design-principles/#atoms","title":"Atoms","text":"<p>Atoms are the fundamental, indivisible building blocks of SilverLingua. They represent single-purpose, foundational components that can't be broken down further while remaining useful.</p> <p>Characteristics:</p> <ul> <li>Implement a single, focused piece of functionality</li> <li>Zero external dependencies</li> <li>Are stateless or manage minimal state</li> <li>Completely self-contained</li> <li>Serve as pure building blocks for more complex components</li> </ul> <p>Examples:</p> <ul> <li><code>Memory</code>: Basic unit of storage</li> <li><code>Prompt</code>: Single unit of instruction or query</li> <li><code>Role</code>: Individual behavior definition</li> <li><code>Tool</code>: Single capability implementation</li> <li><code>Tokenizer</code>: Basic text processing unit</li> </ul>"},{"location":"design-principles/#molecules","title":"Molecules","text":"<p>Molecules represent self-contained conceptual units that combine atoms to create more complex but focused components. They focus on \"what something is\" rather than \"what it does.\"</p> <p>Characteristics:</p> <ul> <li>Represent individual concepts or relationships</li> <li>Manage state and properties of a single conceptual unit</li> <li>Can compose with other molecules</li> <li>Don't orchestrate complex behaviors</li> <li>Focus on representation over action</li> </ul> <p>Examples:</p> <ul> <li><code>Notion</code>: Represents a single thought or concept</li> <li><code>Link</code>: Represents a relationship between components (extends Notion)</li> </ul>"},{"location":"design-principles/#organisms","title":"Organisms","text":"<p>Organisms are complex components that coordinate multiple molecules and atoms to perform sophisticated tasks. They focus on \"what something does\" and how it orchestrates behavior.</p> <p>Characteristics:</p> <ul> <li>Coordinate multiple components</li> <li>Implement complex workflows</li> <li>Manage system-wide behaviors</li> <li>Orchestrate interactions between molecules</li> <li>Focus on action and coordination</li> </ul> <p>Examples:</p> <ul> <li><code>Idearium</code>: Manages a network of thoughts and their relationships</li> </ul>"},{"location":"design-principles/#templates","title":"Templates","text":"<p>Templates define core interfaces and abstract base classes that ensure consistency across the system. They establish patterns that other components must follow while keeping implementation details flexible.</p> <p>Characteristics:</p> <ul> <li>Define standard interfaces with intuitive lifecycle methods</li> <li>Provide minimal base implementations</li> <li>Ensure architectural consistency</li> <li>Enable modularity and extensibility</li> <li>Allow surgical modifications of specific behaviors</li> </ul> <p>Examples:</p> <ul> <li><code>Agent</code>: Base template for AI agents</li> <li><code>Model</code>: Interface for language model implementations, with clear lifecycle methods</li> </ul>"},{"location":"design-principles/#design-guidelines","title":"Design Guidelines","text":""},{"location":"design-principles/#when-to-create-each-type","title":"When to Create Each Type","text":""},{"location":"design-principles/#create-an-atom-when","title":"Create an Atom when:","text":"<ul> <li>You need a fundamental, single-purpose component</li> <li>The functionality can't be meaningfully broken down further</li> <li>It will be reused across many different contexts</li> <li>It can exist without any external dependencies</li> </ul>"},{"location":"design-principles/#create-a-molecule-when","title":"Create a Molecule when:","text":"<ul> <li>You need to represent a concept or relationship</li> <li>You're combining multiple atoms into a cohesive unit</li> <li>The focus is on \"what something is\"</li> <li>The component needs to maintain its own state</li> </ul>"},{"location":"design-principles/#create-an-organism-when","title":"Create an Organism when:","text":"<ul> <li>You need to coordinate multiple molecules or atoms</li> <li>You're implementing complex workflows</li> <li>The focus is on \"what something does\"</li> <li>You need to manage system-wide behavior</li> </ul>"},{"location":"design-principles/#create-a-template-when","title":"Create a Template when:","text":"<ul> <li>You're defining a core interface that others will implement</li> <li>You need to ensure consistency across multiple implementations</li> <li>You're establishing a fundamental pattern with clear lifecycle methods</li> </ul>"},{"location":"design-principles/#composition-rules","title":"Composition Rules","text":"<ol> <li>Atoms must be completely self-contained with zero external dependencies</li> <li>Molecules can depend on atoms and compose with other molecules</li> <li>Organisms can use any components but should focus on coordination</li> <li>Templates should minimize dependencies and focus on clear, intuitive interfaces</li> </ol>"},{"location":"design-principles/#naming-conventions","title":"Naming Conventions","text":"<ul> <li>Atoms: Simple, foundational concepts (<code>Memory</code>, <code>Tool</code>, <code>Role</code>)</li> <li>Molecules: Conceptual nouns (<code>Notion</code>, <code>Link</code>)</li> <li>Organisms: Action-oriented or system concepts (<code>Idearium</code>)</li> <li>Templates: Abstract patterns (<code>Agent</code>, <code>Model</code>)</li> </ul>"},{"location":"design-principles/#contributing","title":"Contributing","text":"<p>When contributing new components to SilverLingua:</p> <ol> <li>Identify the appropriate layer for your component based on its purpose and complexity</li> <li>Follow the design guidelines for that layer</li> <li>Maintain clear separation of concerns</li> <li>Keep it simple - if it feels complicated, it probably needs to be broken down</li> <li>Consider composition over inheritance when possible</li> <li>Ensure modifications can be made surgically without side effects</li> </ol>"},{"location":"design-principles/#real-world-analogies","title":"Real-World Analogies","text":"<p>Think of SilverLingua's architecture like a biological system:</p> <ul> <li>Atoms are like proteins: fundamental, self-contained building blocks</li> <li>Molecules are like cells: self-contained units with specific purposes</li> <li>Organisms are like organs: coordinating multiple parts for complex functions</li> <li>Templates are like DNA: blueprints that define how components should be structured</li> </ul> <p>This biological metaphor helps maintain consistency in design decisions and makes the system more intuitive to understand and extend.</p>"},{"location":"api/","title":"API Reference","text":"<p>options: show_root_heading: true show_source: true</p>"},{"location":"api/#SilverLingua","title":"SilverLingua","text":"<p>SilverLingua - An AI agent framework</p>"},{"location":"api/#SilverLingua.Config","title":"Config","text":""},{"location":"api/#SilverLingua.Config.modules","title":"modules  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>modules: List[Module] = []\n</code></pre>"},{"location":"api/#SilverLingua.Config.chat_roles","title":"chat_roles  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>chat_roles: List[type[ChatRole]] = [ChatRole]\n</code></pre>"},{"location":"api/#SilverLingua.Config.react_roles","title":"react_roles  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>react_roles: List[type[ReactRole]] = [ReactRole]\n</code></pre>"},{"location":"api/#SilverLingua.Config.tools","title":"tools  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tools: List[Tool] = []\n</code></pre>"},{"location":"api/#SilverLingua.Config.get_chat_role","title":"get_chat_role  <code>classmethod</code>","text":"<pre><code>get_chat_role(role: str) -&gt; Optional[ChatRole]\n</code></pre> <p>Attempts to get the standardized ChatRole enum from 'role'. If not, returns None.</p> <p>This is usually used internally for maintaining consistency in Notions across different LLM backends.</p> Source code in <code>src/SilverLingua/config.py</code> <pre><code>@classmethod\ndef get_chat_role(self, role: str) -&gt; Optional[ChatRole]:\n    \"\"\"\n    Attempts to get the standardized ChatRole enum from 'role'.\n    If not, returns None.\n\n    This is usually used internally for maintaining\n    consistency in Notions across different LLM backends.\n    \"\"\"\n    for enum_class in self.chat_roles:\n        for enum_member in enum_class:\n            if str(enum_member.value).lower() == str(role).lower():\n                return ChatRole[enum_member.name]\n    return None\n</code></pre>"},{"location":"api/#SilverLingua.Config.get_react_role","title":"get_react_role  <code>classmethod</code>","text":"<pre><code>get_react_role(role: str) -&gt; Optional[ReactRole]\n</code></pre> <p>Attempts to get the standardized ReactRole enum from 'role'. If not, returns None.</p> <p>This is usually used internally for maintaining consistency in Notions across different LLM backends.</p> Source code in <code>src/SilverLingua/config.py</code> <pre><code>@classmethod\ndef get_react_role(self, role: str) -&gt; Optional[ReactRole]:\n    \"\"\"\n    Attempts to get the standardized ReactRole enum from 'role'.\n    If not, returns None.\n\n    This is usually used internally for maintaining\n    consistency in Notions across different LLM backends.\n    \"\"\"\n    for enum_class in self.react_roles:\n        for enum_member in enum_class:\n            if enum_member.value == role:\n                return ReactRole[enum_member.name]\n    return None\n</code></pre>"},{"location":"api/#SilverLingua.Config.get_tool","title":"get_tool  <code>classmethod</code>","text":"<pre><code>get_tool(name: str) -&gt; Optional[Tool]\n</code></pre> <p>Attempts to get the tool with the given name. If not, returns None.</p> Source code in <code>src/SilverLingua/config.py</code> <pre><code>@classmethod\ndef get_tool(self, name: str) -&gt; Optional[Tool]:\n    \"\"\"\n    Attempts to get the tool with the given name.\n    If not, returns None.\n    \"\"\"\n    for tool in self.tools:\n        if tool.name == name:\n            return tool\n    return None\n</code></pre>"},{"location":"api/#SilverLingua.Config.add_tool","title":"add_tool  <code>classmethod</code>","text":"<pre><code>add_tool(tool: Tool) -&gt; None\n</code></pre> <p>Adds a tool to the config.</p> Source code in <code>src/SilverLingua/config.py</code> <pre><code>@classmethod\ndef add_tool(self, tool: Tool) -&gt; None:\n    \"\"\"\n    Adds a tool to the config.\n    \"\"\"\n    self.tools.append(tool)\n</code></pre>"},{"location":"api/#SilverLingua.Config.add_chat_role","title":"add_chat_role  <code>classmethod</code>","text":"<pre><code>add_chat_role(role: Type[Enum]) -&gt; None\n</code></pre> <p>Adds a chat role to the config.</p> Source code in <code>src/SilverLingua/config.py</code> <pre><code>@classmethod\ndef add_chat_role(self, role: Type[Enum]) -&gt; None:\n    \"\"\"\n    Adds a chat role to the config.\n    \"\"\"\n    if not issubclass(role, Enum):\n        raise TypeError(\"Expected an enum\")\n    self.chat_roles.append(role)\n</code></pre>"},{"location":"api/#SilverLingua.Config.add_react_role","title":"add_react_role  <code>classmethod</code>","text":"<pre><code>add_react_role(role: Type[Enum]) -&gt; None\n</code></pre> <p>Adds a react role to the config.</p> Source code in <code>src/SilverLingua/config.py</code> <pre><code>@classmethod\ndef add_react_role(self, role: Type[Enum]) -&gt; None:\n    \"\"\"\n    Adds a react role to the config.\n    \"\"\"\n    if not issubclass(role, Enum):\n        raise TypeError(\"Expected an enum\")\n    self.react_roles.append(role)\n</code></pre>"},{"location":"api/#SilverLingua.Config.register_module","title":"register_module  <code>classmethod</code>","text":"<pre><code>register_module(module: Module) -&gt; None\n</code></pre> <p>Registers a module.</p> Source code in <code>src/SilverLingua/config.py</code> <pre><code>@classmethod\ndef register_module(self, module: Module) -&gt; None:\n    \"\"\"\n    Registers a module.\n    \"\"\"\n    self.modules.append(module)\n    for tool in module.tools:\n        self.add_tool(tool)\n    for chat_role in module.chat_roles:\n        self.add_chat_role(chat_role)\n    for react_role in module.react_roles:\n        self.add_react_role(react_role)\n\n    logger.debug(\n        f'Registered module {module.name}@{module.version}: \"{module.description}\"'\n    )\n</code></pre>"},{"location":"api/#SilverLingua.Module","title":"Module","text":"<pre><code>Module(name: str, description: str, version: str, tools: List[Tool], chat_roles: List[type[ChatRole]], react_roles: List[type[ReactRole]], **kwargs)\n</code></pre> <p>               Bases: <code>BaseModel</code></p> <p>A module that can be loaded into SilverLingua.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the module.</p> <code>description</code> <code>str</code> <p>A description of the module.</p> <code>version</code> <code>str</code> <p>The version of the module.</p> <code>tools</code> <code>List[Tool]</code> <p>The tools in the module.</p> <code>chat_roles</code> <code>List[type[ChatRole]]</code> <p>The chat roles in the module.</p> <code>react_roles</code> <code>List[type[ReactRole]]</code> <p>The react roles in the module.</p> Source code in <code>src/SilverLingua/config.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    description: str,\n    version: str,\n    tools: List[Tool],\n    chat_roles: List[type[ChatRole]],\n    react_roles: List[type[ReactRole]],\n    **kwargs,\n):\n    super().__init__(\n        name=name,\n        description=description,\n        version=version,\n        tools=tools,\n        chat_roles=chat_roles,\n        react_roles=react_roles,\n        **kwargs,\n    )\n\n    Config.register_module(self)\n</code></pre>"},{"location":"api/#SilverLingua.Module.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/#SilverLingua.Module.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str\n</code></pre>"},{"location":"api/#SilverLingua.Module.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: str\n</code></pre>"},{"location":"api/#SilverLingua.Module.tools","title":"tools  <code>instance-attribute</code>","text":"<pre><code>tools: List[Tool]\n</code></pre>"},{"location":"api/#SilverLingua.Module.chat_roles","title":"chat_roles  <code>instance-attribute</code>","text":"<pre><code>chat_roles: List[type[ChatRole]]\n</code></pre>"},{"location":"api/#SilverLingua.Module.react_roles","title":"react_roles  <code>instance-attribute</code>","text":"<pre><code>react_roles: List[type[ReactRole]]\n</code></pre>"},{"location":"api/#SilverLingua.Module.check_chat_roles","title":"check_chat_roles","text":"<pre><code>check_chat_roles(v)\n</code></pre> Source code in <code>src/SilverLingua/config.py</code> <pre><code>@field_validator(\"chat_roles\", mode=\"plain\")\ndef check_chat_roles(cls, v):\n    for role in v:\n        if not issubclass(role, Enum):\n            raise TypeError(\"Expected an enum\")\n        else:\n            for member in role:\n                if (\n                    not ChatRole[member.name]\n                    or member.value != ChatRole[member.name].value\n                ):\n                    raise TypeError(\"members must match ChatRole members.\")\n    return v\n</code></pre>"},{"location":"api/#SilverLingua.Module.check_react_roles","title":"check_react_roles","text":"<pre><code>check_react_roles(v)\n</code></pre> Source code in <code>src/SilverLingua/config.py</code> <pre><code>@field_validator(\"react_roles\", mode=\"plain\")\ndef check_react_roles(cls, v):\n    for role in v:\n        if not issubclass(role, Enum):\n            raise TypeError(\"Expected an enum\")\n        else:\n            for member in role:\n                if (\n                    not ReactRole[member.name]\n                    or member.value != ReactRole[member.name].value\n                ):\n                    raise TypeError(\"members must match ReactRole members.\")\n    return v\n</code></pre>"},{"location":"api/#SilverLingua.ChatRole","title":"ChatRole","text":"<p>               Bases: <code>Enum</code></p> <p>Standardized roles for chat messages.</p> Warning <p>Do not instantiate this enum directly. Use <code>create_chat_role()</code> instead.</p>"},{"location":"api/#SilverLingua.ChatRole.SYSTEM","title":"SYSTEM  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SYSTEM = RoleMember('SYSTEM', 'SYSTEM')\n</code></pre>"},{"location":"api/#SilverLingua.ChatRole.HUMAN","title":"HUMAN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HUMAN = RoleMember('HUMAN', 'HUMAN')\n</code></pre>"},{"location":"api/#SilverLingua.ChatRole.AI","title":"AI  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AI = RoleMember('AI', 'AI')\n</code></pre>"},{"location":"api/#SilverLingua.ChatRole.TOOL_CALL","title":"TOOL_CALL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TOOL_CALL = RoleMember('TOOL_CALL', 'TOOL_CALL')\n</code></pre>"},{"location":"api/#SilverLingua.ChatRole.TOOL_RESPONSE","title":"TOOL_RESPONSE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TOOL_RESPONSE = RoleMember('TOOL_RESPONSE', 'TOOL_RESPONSE')\n</code></pre>"},{"location":"api/#SilverLingua.Memory","title":"Memory","text":"<p>               Bases: <code>BaseModel</code></p> <p>A Memory is the smallest unit of storage information, and is the base class for all other storage information like <code>Notion</code>.</p>"},{"location":"api/#SilverLingua.Memory.content","title":"content  <code>instance-attribute</code>","text":"<pre><code>content: str\n</code></pre>"},{"location":"api/#SilverLingua.ReactRole","title":"ReactRole","text":"<p>               Bases: <code>Enum</code></p> <p>Standardized roles for ReAct framework to help with chain-of-thought prompting.</p> <p>See: https://www.promptingguide.ai/techniques/react</p> Warning <p>Do not instantiate this enum directly. Use <code>create_react_role()</code> instead.</p>"},{"location":"api/#SilverLingua.ReactRole.QUESTION","title":"QUESTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>QUESTION = RoleMember('QUESTION', 'QUESTION')\n</code></pre>"},{"location":"api/#SilverLingua.ReactRole.THOUGHT","title":"THOUGHT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>THOUGHT = RoleMember('THOUGHT', 'THOUGHT')\n</code></pre>"},{"location":"api/#SilverLingua.ReactRole.ACTION","title":"ACTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTION = RoleMember('ACTION', 'ACTION')\n</code></pre>"},{"location":"api/#SilverLingua.ReactRole.OBSERVATION","title":"OBSERVATION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OBSERVATION = RoleMember('OBSERVATION', 'OBSERVATION')\n</code></pre>"},{"location":"api/#SilverLingua.ReactRole.ANSWER","title":"ANSWER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ANSWER = RoleMember('ANSWER', 'ANSWER')\n</code></pre>"},{"location":"api/#SilverLingua.Tool","title":"Tool","text":"<pre><code>Tool(function: Callable)\n</code></pre> <p>               Bases: <code>BaseModel</code></p> <p>A wrapper class for functions that allows them to be both directly callable and serializable to JSON for use with an LLM.</p> <p>Attributes:</p> Name Type Description <code>function</code> <code>Callable</code> <p>The function to be wrapped.</p> <code>description</code> <code>FunctionJSONSchema</code> <p>A TypedDict that describes the function according to JSON schema standards.</p> <code>name</code> <code>str</code> <p>The name of the function, extracted from the FunctionJSONSchema.</p> See also <ul> <li><code>Agent</code></li> <li><code>Model</code></li> </ul> Example <pre><code>def my_function(x, y):\n    return x + y\n\n# Create a Tool instance\ntool_instance = Tool(my_function)\n\n# Directly call the wrapped function\nresult = tool_instance(1, 2)  # Output will be 3\n\n# Serialize to JSON\nserialized = str(tool_instance)\n\n####\n# Alternatively, you can use the decorator to turn a function into a Tool.\n####\n\n@tool\ndef my_function(x, y):\n    return x + y\n\n# Now the function itself is already a Tool.\nresult = my_function(1, 2)  # Output will be 3\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Callable</code> <p>The function to be turned into a Tool.</p> required Source code in <code>src/SilverLingua/core/atoms/tool/tool.py</code> <pre><code>def __init__(self, function: Callable):\n    \"\"\"\n    Args:\n        function (Callable): The function to be turned into a Tool.\n    \"\"\"\n    description = generate_function_json(function)\n    name = description.name\n    super().__init__(function=function, description=description, name=name)\n</code></pre>"},{"location":"api/#SilverLingua.Tool.function","title":"function  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>function: Callable = Field(exclude=True)\n</code></pre>"},{"location":"api/#SilverLingua.Tool.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: FunctionJSONSchema = Field(validate_default=True)\n</code></pre>"},{"location":"api/#SilverLingua.Tool.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = Field(validate_default=True)\n</code></pre>"},{"location":"api/#SilverLingua.Tool.use_function_call","title":"use_function_call","text":"<pre><code>use_function_call(function_call: ToolCallFunction)\n</code></pre> <p>Uses a FunctionCall to call the function.</p> Source code in <code>src/SilverLingua/core/atoms/tool/tool.py</code> <pre><code>def use_function_call(self, function_call: ToolCallFunction):\n    \"\"\"\n    Uses a FunctionCall to call the function.\n    \"\"\"\n    arguments_dict = function_call.arguments\n    if arguments_dict == \"\":\n        return json.dumps(self.function())\n\n    try:\n        arguments_dict = json.loads(function_call.arguments)\n    except json.JSONDecodeError:\n        raise ValueError(\n            \"ToolCall.arguments must be a JSON string.\\n\"\n            + f\"function_call.arguments: {function_call.arguments}\\n\"\n            + f\"json.loads result: {arguments_dict}\"\n        ) from None\n\n    return json.dumps(self.function(**arguments_dict))\n</code></pre>"},{"location":"api/#SilverLingua.ToolCall","title":"ToolCall","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/#SilverLingua.ToolCall.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(extra='allow', ignored_types=(type(None)))\n</code></pre>"},{"location":"api/#SilverLingua.ToolCall.function","title":"function  <code>instance-attribute</code>","text":"<pre><code>function: ToolCallFunction\n</code></pre>"},{"location":"api/#SilverLingua.ToolCall.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = Field(default_factory=lambda: str(uuid4()))\n</code></pre>"},{"location":"api/#SilverLingua.ToolCall.index","title":"index  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>index: Optional[int] = None\n</code></pre>"},{"location":"api/#SilverLingua.ToolCall.string_if_none","title":"string_if_none","text":"<pre><code>string_if_none(v)\n</code></pre> Source code in <code>src/SilverLingua/core/atoms/tool/util.py</code> <pre><code>@field_validator(\"id\", mode=\"before\")\ndef string_if_none(cls, v):\n    return v if v is not None else str(uuid4())\n</code></pre>"},{"location":"api/#SilverLingua.ToolCall.concat","title":"concat","text":"<pre><code>concat(other: ToolCall) -&gt; ToolCall\n</code></pre> <p>Concatenates two tool calls and returns the result.</p> <p>If the IDs are different, prioritize the ID of 'self'. For 'function', merge the 'name' and 'arguments' fields.</p> <p>We will prefer the <code>id</code> of self over other for 2 reasons: 1. We assume that self is the older of the two 2. The newer may be stream chunked, in which case the <code>id</code> of <code>other</code> may have been <code>None</code> and generated using UUID, but the older ID likely was generated by an API and thus this newer ID is not the true ID.</p> Source code in <code>src/SilverLingua/core/atoms/tool/util.py</code> <pre><code>def concat(self, other: \"ToolCall\") -&gt; \"ToolCall\":\n    \"\"\"\n    Concatenates two tool calls and returns the result.\n\n    If the IDs are different, prioritize the ID of 'self'.\n    For 'function', merge the 'name' and 'arguments' fields.\n\n    We will prefer the `id` of self over other for 2 reasons:\n    1. We assume that self is the older of the two\n    2. The newer may be stream chunked, in which case\n    the `id` of `other` may have been `None` and generated\n    using UUID, but the older ID likely was generated\n    by an API and thus this newer ID is not the true ID.\n    \"\"\"\n    merged_function = {\n        \"name\": self.function.name or other.function.name,\n        \"arguments\": (self.function.arguments or \"\")\n        + (other.function.arguments or \"\"),\n    }\n    merged_function = ToolCallFunction(**merged_function)\n\n    self_extra = self.__pydantic_extra__\n    other_extra = other.__pydantic_extra__\n\n    index = self.index if self.index is not None else other.index\n\n    # Compare the two extra fields\n    if self_extra != other_extra:\n        if not self_extra or not other_extra:\n            return ToolCall(\n                id=(self.id) or other.id,\n                function=merged_function,\n                index=index,\n                **(self_extra or {}),\n                **(other_extra or {}),\n            )\n        # If they are different, merge them\n        merged_extra = {}\n        for key in set(self_extra.keys()) | set(other_extra.keys()):\n            if key in self_extra and key in other_extra:\n                # If one is None, use the other\n                # Else, concatenate them\n                if self_extra[key] == other_extra[key]:\n                    merged_extra[key] = self_extra[key]\n                else:\n                    if self_extra[key] is None or other_extra[key] is None:\n                        merged_extra[key] = self_extra[key] or other_extra[key]\n                    else:\n                        merged_extra[key] = self_extra[key] + other_extra[key]\n            elif key in self_extra:\n                merged_extra[key] = self_extra[key]\n            elif key in other_extra:\n                merged_extra[key] = other_extra[key]\n        #\n        return ToolCall(\n            id=self.id or other.id,\n            function=merged_function,\n            index=index,\n            **merged_extra,\n        )\n\n    return ToolCall(\n        id=self.id or other.id,\n        function=merged_function,\n        index=index,\n        **(self_extra or {}),\n    )\n</code></pre>"},{"location":"api/#SilverLingua.ToolCallFunction","title":"ToolCallFunction","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/#SilverLingua.ToolCallFunction.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = Field(default='')\n</code></pre>"},{"location":"api/#SilverLingua.ToolCallFunction.arguments","title":"arguments  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>arguments: str = Field(default='')\n</code></pre>"},{"location":"api/#SilverLingua.ToolCallFunction.string_if_none","title":"string_if_none","text":"<pre><code>string_if_none(v)\n</code></pre> Source code in <code>src/SilverLingua/core/atoms/tool/util.py</code> <pre><code>@field_validator(\"*\", mode=\"before\")\ndef string_if_none(cls, v):\n    return v if v is not None else \"\"\n</code></pre>"},{"location":"api/#SilverLingua.ToolCallResponse","title":"ToolCallResponse","text":"<p>               Bases: <code>BaseModel</code></p> <p>The response property of a tool call.</p>"},{"location":"api/#SilverLingua.ToolCallResponse.tool_call_id","title":"tool_call_id  <code>instance-attribute</code>","text":"<pre><code>tool_call_id: str\n</code></pre>"},{"location":"api/#SilverLingua.ToolCallResponse.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/#SilverLingua.ToolCallResponse.content","title":"content  <code>instance-attribute</code>","text":"<pre><code>content: str\n</code></pre>"},{"location":"api/#SilverLingua.ToolCallResponse.from_tool_call","title":"from_tool_call  <code>classmethod</code>","text":"<pre><code>from_tool_call(tool_call: ToolCall, response: str) -&gt; ToolCallResponse\n</code></pre> Source code in <code>src/SilverLingua/core/atoms/tool/util.py</code> <pre><code>@classmethod\ndef from_tool_call(cls, tool_call: \"ToolCall\", response: str) -&gt; \"ToolCallResponse\":\n    return cls(\n        tool_call_id=tool_call.id,\n        name=tool_call.function.name,\n        content=response,\n    )\n</code></pre>"},{"location":"api/#SilverLingua.ToolCalls","title":"ToolCalls","text":"<p>               Bases: <code>BaseModel</code></p> <p>A list of tool calls.</p>"},{"location":"api/#SilverLingua.ToolCalls.list","title":"list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>list: List[ToolCall] = Field(default_factory=list, frozen=True)\n</code></pre>"},{"location":"api/#SilverLingua.ToolCalls.concat","title":"concat","text":"<pre><code>concat(other: ToolCalls) -&gt; ToolCalls\n</code></pre> <p>Concatenates two tool calls lists and returns the result.</p> Source code in <code>src/SilverLingua/core/atoms/tool/util.py</code> <pre><code>def concat(self, other: \"ToolCalls\") -&gt; \"ToolCalls\":\n    \"\"\"\n    Concatenates two tool calls lists and returns the result.\n    \"\"\"\n    new: List[ToolCall] = self.list.copy()\n    for tool_call in other.list:\n        found = False\n        # Find the tool call with the same ID\n        for i, self_tool_call in enumerate(new):\n            if (\n                self_tool_call.id == tool_call.id\n                or self_tool_call.index == tool_call.index\n            ):\n                new[i] = self_tool_call.concat(tool_call)\n                found = True\n        if not found:\n            new.append(tool_call)\n    return ToolCalls(list=new)\n</code></pre>"},{"location":"api/#SilverLingua.Link","title":"Link","text":"<p>               Bases: <code>Memory</code></p> <p>A memory that can have a parent and children Links, forming a hierarchical structure of interconnected memories.</p> <p>The content can be either a <code>Notion</code> or a <code>Memory</code>. (You can still use the content as a string via <code>str(link.content)</code>.)</p>"},{"location":"api/#SilverLingua.Link.content","title":"content  <code>instance-attribute</code>","text":"<pre><code>content: Union[Notion, Memory]\n</code></pre>"},{"location":"api/#SilverLingua.Link.parent","title":"parent  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parent: Optional[Link] = None\n</code></pre>"},{"location":"api/#SilverLingua.Link.children","title":"children  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>children: List[Link] = Field(default_factory=list)\n</code></pre>"},{"location":"api/#SilverLingua.Link.path","title":"path  <code>property</code>","text":"<pre><code>path: List[Link]\n</code></pre> <p>Returns the path from the root to this Link.</p>"},{"location":"api/#SilverLingua.Link.root","title":"root  <code>property</code>","text":"<pre><code>root: Link\n</code></pre> <p>Returns the root Link of this Link.</p>"},{"location":"api/#SilverLingua.Link.depth","title":"depth  <code>property</code>","text":"<pre><code>depth: int\n</code></pre> <p>Returns 1 based depth of this Link.</p>"},{"location":"api/#SilverLingua.Link.is_root","title":"is_root  <code>property</code>","text":"<pre><code>is_root: bool\n</code></pre> <p>Returns whether this Link is a root Link.</p>"},{"location":"api/#SilverLingua.Link.is_leaf","title":"is_leaf  <code>property</code>","text":"<pre><code>is_leaf: bool\n</code></pre> <p>Returns whether this Link is a leaf Link.</p>"},{"location":"api/#SilverLingua.Link.is_branch","title":"is_branch  <code>property</code>","text":"<pre><code>is_branch: bool\n</code></pre> <p>Returns whether this Link is a branch Link.</p>"},{"location":"api/#SilverLingua.Link.path_string","title":"path_string  <code>property</code>","text":"<pre><code>path_string: str\n</code></pre> <p>Returns the path from the root to this Link as a string.</p> <p>Example: \"root&gt;child&gt;grandchild\"</p>"},{"location":"api/#SilverLingua.Link.add_child","title":"add_child","text":"<pre><code>add_child(child: Link) -&gt; None\n</code></pre> Source code in <code>src/SilverLingua/core/molecules/link.py</code> <pre><code>def add_child(self, child: \"Link\") -&gt; None:\n    self.children.append(child)\n    child.parent = self\n</code></pre>"},{"location":"api/#SilverLingua.Link.remove_child","title":"remove_child","text":"<pre><code>remove_child(child: Link) -&gt; None\n</code></pre> Source code in <code>src/SilverLingua/core/molecules/link.py</code> <pre><code>def remove_child(self, child: \"Link\") -&gt; None:\n    self.children.remove(child)\n    child.parent = None\n</code></pre>"},{"location":"api/#SilverLingua.Notion","title":"Notion","text":"<pre><code>Notion(content: str, role: Union[ChatRole, ReactRole, str], persistent: bool = False)\n</code></pre> <p>               Bases: <code>Memory</code></p> <p>A memory that stores the role associated with its content. The role is usually a <code>ChatRole</code> or a <code>ReactRole</code>. (See <code>atoms/roles</code>)</p> <p>Attributes:</p> Name Type Description <code>role</code> <code>str</code> <p>The role of the notion.</p> <code>content</code> <code>str</code> <p>The content of the memory.</p> <code>persistent</code> <code>bool</code> <p>Whether the notion should be stored in long-term memory.</p> Source code in <code>src/SilverLingua/core/molecules/notion.py</code> <pre><code>def __init__(\n    self,\n    content: str,\n    role: Union[ChatRole, ReactRole, str],\n    persistent: bool = False,\n):\n    super().__init__(content=content, role=role, persistent=persistent)\n</code></pre>"},{"location":"api/#SilverLingua.Notion.content","title":"content  <code>instance-attribute</code>","text":"<pre><code>content: str\n</code></pre>"},{"location":"api/#SilverLingua.Notion.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(from_attributes=True)\n</code></pre>"},{"location":"api/#SilverLingua.Notion.role","title":"role  <code>instance-attribute</code>","text":"<pre><code>role: str\n</code></pre>"},{"location":"api/#SilverLingua.Notion.persistent","title":"persistent  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>persistent: bool = False\n</code></pre>"},{"location":"api/#SilverLingua.Notion.chat_role","title":"chat_role  <code>property</code>","text":"<pre><code>chat_role: ChatRole\n</code></pre> <p>Gets the chat based role Enum (e.g. Role.SYSTEM, Role.HUMAN, etc.)</p> <p>(See <code>config</code>)</p>"},{"location":"api/#SilverLingua.Notion.react_role","title":"react_role  <code>property</code>","text":"<pre><code>react_role: ReactRole\n</code></pre> <p>Gets the react based role Enum (e.g. Role.THOUGHT, Role.OBSERVATION, etc.)</p> <p>(See <code>config</code>)</p>"},{"location":"api/#SilverLingua.Notion.validate_role","title":"validate_role  <code>classmethod</code>","text":"<pre><code>validate_role(v: Union[ChatRole, ReactRole, str])\n</code></pre> Source code in <code>src/SilverLingua/core/molecules/notion.py</code> <pre><code>@field_validator(\"role\", mode=\"before\")\n@classmethod\ndef validate_role(cls, v: Union[ChatRole, ReactRole, str]):\n    if isinstance(v, (ChatRole, ReactRole)):\n        return v.value.value\n    elif isinstance(v, str):\n        return v\n    raise ValueError(f\"Expected a ChatRole, ReactRole, or a string, got {type(v)}\")\n</code></pre>"},{"location":"api/#SilverLingua.Idearium","title":"Idearium","text":"<pre><code>Idearium(tokenizer: Tokenizer, max_tokens: int, notions: List[Notion] = None, **kwargs)\n</code></pre> <p>               Bases: <code>BaseModel</code></p> <p>A collection of <code>Notions</code> that is automatically trimmed to fit within a maximum number of tokens.</p> Source code in <code>src/SilverLingua/core/organisms/idearium.py</code> <pre><code>def __init__(\n    self,\n    tokenizer: Tokenizer,\n    max_tokens: int,\n    notions: List[Notion] = None,\n    **kwargs,\n):\n    # Initialize with empty notions if None\n    notions = notions or []\n\n    # Initialize tokenized_notions\n    tokenized_notions = [tokenizer.encode(notion.content) for notion in notions]\n\n    # Call parent init with all values\n    super().__init__(\n        tokenizer=tokenizer,\n        max_tokens=max_tokens,\n        notions=notions,\n        tokenized_notions=tokenized_notions,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#SilverLingua.Idearium.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(frozen=True)\n</code></pre>"},{"location":"api/#SilverLingua.Idearium.tokenizer","title":"tokenizer  <code>instance-attribute</code>","text":"<pre><code>tokenizer: Tokenizer\n</code></pre>"},{"location":"api/#SilverLingua.Idearium.max_tokens","title":"max_tokens  <code>instance-attribute</code>","text":"<pre><code>max_tokens: int\n</code></pre>"},{"location":"api/#SilverLingua.Idearium.notions","title":"notions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>notions: List[Notion] = Field(default_factory=list)\n</code></pre>"},{"location":"api/#SilverLingua.Idearium.tokenized_notions","title":"tokenized_notions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tokenized_notions: List[List[int]] = Field(default_factory=list)\n</code></pre>"},{"location":"api/#SilverLingua.Idearium.persistent_indices","title":"persistent_indices  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>persistent_indices: set = Field(default_factory=set)\n</code></pre>"},{"location":"api/#SilverLingua.Idearium.total_tokens","title":"total_tokens  <code>property</code>","text":"<pre><code>total_tokens: int\n</code></pre> <p>The total number of tokens in the Idearium.</p>"},{"location":"api/#SilverLingua.Idearium._non_persistent_indices","title":"_non_persistent_indices  <code>property</code>","text":"<pre><code>_non_persistent_indices: set\n</code></pre> <p>The indices of non-persistent notions.</p>"},{"location":"api/#SilverLingua.Idearium.validate_notions","title":"validate_notions","text":"<pre><code>validate_notions(values)\n</code></pre> Source code in <code>src/SilverLingua/core/organisms/idearium.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_notions(cls, values):\n    notions = values.notions\n    for notion in notions:\n        cls.validate_notion(notion, values.max_tokens, values.tokenizer)\n    return values\n</code></pre>"},{"location":"api/#SilverLingua.Idearium.validate_notion","title":"validate_notion  <code>classmethod</code>","text":"<pre><code>validate_notion(notion: Notion, max_tokens: int, tokenizer: Tokenizer)\n</code></pre> Source code in <code>src/SilverLingua/core/organisms/idearium.py</code> <pre><code>@classmethod\ndef validate_notion(cls, notion: Notion, max_tokens: int, tokenizer: Tokenizer):\n    if len(notion.content) == 0:\n        raise ValueError(\"Notion content cannot be empty.\")\n\n    tokenized_notion = tokenizer.encode(notion.content)\n    if len(tokenized_notion) &gt; max_tokens:\n        raise ValueError(\"Notion exceeds maximum token length\")\n\n    return tokenized_notion\n</code></pre>"},{"location":"api/#SilverLingua.Idearium.index","title":"index","text":"<pre><code>index(notion: Notion) -&gt; int\n</code></pre> <p>Returns the index of the first occurrence of the given notion.</p> Source code in <code>src/SilverLingua/core/organisms/idearium.py</code> <pre><code>def index(self, notion: Notion) -&gt; int:\n    \"\"\"Returns the index of the first occurrence of the given notion.\"\"\"\n    return self.notions.index(notion)\n</code></pre>"},{"location":"api/#SilverLingua.Idearium.append","title":"append","text":"<pre><code>append(notion: Notion)\n</code></pre> <p>Appends the given notion to the end of the Idearium.</p> Source code in <code>src/SilverLingua/core/organisms/idearium.py</code> <pre><code>def append(self, notion: Notion):\n    \"\"\"Appends the given notion to the end of the Idearium.\"\"\"\n    logger.debug(f\"Appending notion: {notion.content!r}\")\n    tokenized_notion = self.tokenizer.encode(notion.content)\n\n    if self.notions:\n        logger.debug(f\"Current last notion: {self.notions[-1].content!r}\")\n\n    if (\n        self.notions\n        and self.notions[-1].role == notion.role\n        and self.notions[-1].persistent == notion.persistent\n    ):\n        combined_content = self.notions[-1].content + notion.content\n        combined_notion = Notion(\n            content=combined_content,\n            role=notion.role,\n            persistent=notion.persistent,\n        )\n        self.replace(len(self.notions) - 1, combined_notion)\n        logger.debug(\n            f\"After replace, about to return combined content: {combined_content!r}\"\n        )\n        return\n\n    logger.debug(f\"Hitting append path. Appending new notion: {notion.content!r}\")\n    self.notions.append(notion)\n    self.tokenized_notions.append(tokenized_notion)\n\n    if notion.persistent:\n        # Modify the set in place instead of reassigning\n        self.persistent_indices.add(len(self.notions) - 1)\n\n    self._trim()\n</code></pre>"},{"location":"api/#SilverLingua.Idearium.extend","title":"extend","text":"<pre><code>extend(notions: Union[List[Notion], Idearium])\n</code></pre> <p>Extends the Idearium with the given list of notions.</p> Source code in <code>src/SilverLingua/core/organisms/idearium.py</code> <pre><code>def extend(self, notions: Union[List[Notion], \"Idearium\"]):\n    \"\"\"Extends the Idearium with the given list of notions.\"\"\"\n    if isinstance(notions, Idearium):\n        notions = notions.notions\n\n    for notion in notions:\n        self.append(notion)\n</code></pre>"},{"location":"api/#SilverLingua.Idearium.insert","title":"insert","text":"<pre><code>insert(index: int, notion: Notion)\n</code></pre> <p>Inserts the given notion at the given index.</p> Source code in <code>src/SilverLingua/core/organisms/idearium.py</code> <pre><code>def insert(self, index: int, notion: Notion):\n    \"\"\"Inserts the given notion at the given index.\"\"\"\n    tokenized_notion = self.tokenizer.encode(notion.content)\n\n    self.notions.insert(index, notion)\n    self.tokenized_notions.insert(index, tokenized_notion)\n\n    # Update persistent_indices in place\n    new_indices = {i + 1 if i &gt;= index else i for i in self.persistent_indices}\n    self.persistent_indices.clear()\n    self.persistent_indices.update(new_indices)\n    if notion.persistent:\n        self.persistent_indices.add(index)\n\n    self._trim()\n</code></pre>"},{"location":"api/#SilverLingua.Idearium.remove","title":"remove","text":"<pre><code>remove(notion: Notion)\n</code></pre> <p>Removes the first occurrence of the given notion.</p> Source code in <code>src/SilverLingua/core/organisms/idearium.py</code> <pre><code>def remove(self, notion: Notion):\n    \"\"\"Removes the first occurrence of the given notion.\"\"\"\n    index = self.index(notion)\n    self.pop(index)\n</code></pre>"},{"location":"api/#SilverLingua.Idearium.pop","title":"pop","text":"<pre><code>pop(index: int) -&gt; Notion\n</code></pre> <p>Removes and returns the notion at the given index.</p> Source code in <code>src/SilverLingua/core/organisms/idearium.py</code> <pre><code>def pop(self, index: int) -&gt; Notion:\n    \"\"\"Removes and returns the notion at the given index.\"\"\"\n    ret = self.notions.pop(index)\n    self.tokenized_notions.pop(index)\n\n    # Update persistent_indices\n    # Modify the set in place instead of reassigning\n    self.persistent_indices.discard(index)\n    new_indices = {i - 1 if i &gt; index else i for i in self.persistent_indices}\n    self.persistent_indices.clear()\n    self.persistent_indices.update(new_indices)\n\n    return ret\n</code></pre>"},{"location":"api/#SilverLingua.Idearium.replace","title":"replace","text":"<pre><code>replace(index: int, notion: Notion)\n</code></pre> <p>Replaces the notion at the given index with the given notion.</p> Source code in <code>src/SilverLingua/core/organisms/idearium.py</code> <pre><code>def replace(self, index: int, notion: Notion):\n    \"\"\"Replaces the notion at the given index with the given notion.\"\"\"\n    self.notions[index] = notion\n    self.tokenized_notions[index] = self.tokenizer.encode(notion.content)\n\n    # Update persistent_indices based on the replaced notion\n    if notion.persistent:\n        self.persistent_indices.add(index)\n    else:\n        self.persistent_indices.discard(index)\n\n    self._trim()\n</code></pre>"},{"location":"api/#SilverLingua.Idearium.copy","title":"copy","text":"<pre><code>copy() -&gt; Idearium\n</code></pre> <p>Returns a copy of the Idearium.</p> Source code in <code>src/SilverLingua/core/organisms/idearium.py</code> <pre><code>def copy(self) -&gt; \"Idearium\":\n    \"\"\"Returns a copy of the Idearium.\"\"\"\n    return Idearium(\n        tokenizer=self.tokenizer,\n        max_tokens=self.max_tokens,\n        notions=self.notions.copy(),\n        tokenized_notions=self.tokenized_notions.copy(),\n        persistent_indices=self.persistent_indices.copy(),\n    )\n</code></pre>"},{"location":"api/#SilverLingua.Idearium._trim","title":"_trim","text":"<pre><code>_trim()\n</code></pre> <p>Trims the Idearium to fit within the maximum number of tokens, called after every modification.</p> <p>This is the primary point of extension for Idearium subclasses, as it allows for custom trimming behavior.</p> Source code in <code>src/SilverLingua/core/organisms/idearium.py</code> <pre><code>def _trim(self):\n    \"\"\"\n    Trims the Idearium to fit within the maximum number of tokens, called\n    after every modification.\n\n    This is the primary point of extension for Idearium subclasses, as it\n    allows for custom trimming behavior.\n    \"\"\"\n    while self.total_tokens &gt; self.max_tokens:\n        non_persistent_indices = self._non_persistent_indices\n\n        # Check if there's only one non-persistent user message\n        if len(non_persistent_indices) == 1:\n            single_index = next(iter(non_persistent_indices))\n            tokenized_notion = self.tokenized_notions[single_index]\n\n            # Trim the only non-persistent notion to fit within the token limit\n            tokenized_notion = tokenized_notion[\n                : self.max_tokens - (self.total_tokens - len(tokenized_notion))\n            ]\n            trimmed_content = self.tokenizer.decode(tokenized_notion)\n            trimmed_notion = Notion(\n                content=trimmed_content,\n                role=self.notions[single_index].role,\n                persistent=self.notions[single_index].persistent,\n            )\n            self.replace(single_index, trimmed_notion)\n            return\n\n        # Attempt to remove the first non-persistent notion\n        for i in non_persistent_indices:\n            self.pop(i)\n            break\n        else:\n            # If all notions are persistent and\n            # the max token length is still exceeded\n            raise ValueError(\n                \"Persistent notions exceed max_tokens.\"\n                + \" Reduce the content or increase max_tokens.\"\n            )\n</code></pre>"},{"location":"api/#SilverLingua.Agent","title":"Agent","text":"<pre><code>Agent(model: Model, idearium: Optional[Idearium] = None, tools: Optional[List[Tool]] = None, auto_append_response: bool = True)\n</code></pre> <p>               Bases: <code>BaseModel</code></p> <p>A wrapper around a <code>Model</code> that utilizes an <code>Idearium</code> and a set of <code>Tool</code>s.</p> <p>This is a base class not meant to be used directly. It is meant to be subclassed by specific model implementations.</p> <p>However, there is limited boilerplate. The only thing that needs to be redefined in subclasses is the <code>_bind_tools</code> method.</p> <p>Additionally, the <code>_use_tools</code> method is a common method to redefine.</p> <p>Initializes the agent.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The model to use.</p> required <code>idearium</code> <code>Idearium</code> <p>The idearium to use. If None, a new one will be created.</p> <code>None</code> <code>tools</code> <code>List[Tool]</code> <p>The tools to use.</p> <code>None</code> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>def __init__(\n    self,\n    model: Model,\n    idearium: Optional[Idearium] = None,\n    tools: Optional[List[Tool]] = None,\n    auto_append_response: bool = True,\n):\n    \"\"\"\n    Initializes the agent.\n\n    Args:\n        model (Model): The model to use.\n        idearium (Idearium, optional): The idearium to use.\n            If None, a new one will be created.\n        tools (List[Tool], optional): The tools to use.\n    \"\"\"\n    super().__init__(\n        model=model,\n        idearium=idearium\n        or Idearium(tokenizer=model.tokenizer, max_tokens=model.max_tokens),\n        tools=tools or [],\n        auto_append_response=auto_append_response,\n    )\n</code></pre>"},{"location":"api/#SilverLingua.Agent.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(frozen=True)\n</code></pre>"},{"location":"api/#SilverLingua.Agent.model","title":"model  <code>property</code>","text":"<pre><code>model: Model\n</code></pre> <p>The model used by the agent.</p>"},{"location":"api/#SilverLingua.Agent.idearium","title":"idearium  <code>instance-attribute</code>","text":"<pre><code>idearium: Idearium\n</code></pre> <p>The Idearium used by the agent.</p>"},{"location":"api/#SilverLingua.Agent.tools","title":"tools  <code>instance-attribute</code>","text":"<pre><code>tools: List[Tool]\n</code></pre> <p>The tools used by the agent.</p> Warning <p>Do not modify this list directly. Use <code>add_tool</code>, <code>add_tools</code>, and <code>remove_tool</code> instead.</p>"},{"location":"api/#SilverLingua.Agent.auto_append_response","title":"auto_append_response  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>auto_append_response: bool = True\n</code></pre> <p>Whether to automatically append the response to the idearium after generating a response.</p>"},{"location":"api/#SilverLingua.Agent.role","title":"role  <code>property</code>","text":"<pre><code>role: ChatRole\n</code></pre> <p>The ChatRole object for the model.</p>"},{"location":"api/#SilverLingua.Agent.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__content)\n</code></pre> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>def model_post_init(self, __content):\n    self._bind_tools()\n</code></pre>"},{"location":"api/#SilverLingua.Agent._find_tool","title":"_find_tool","text":"<pre><code>_find_tool(name: str) -&gt; Tool | None\n</code></pre> <p>Finds a tool by name.</p> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>def _find_tool(self, name: str) -&gt; Tool | None:\n    \"\"\"\n    Finds a tool by name.\n    \"\"\"\n    for t in self.tools:\n        if t.name == name:\n            return t\n    return None\n</code></pre>"},{"location":"api/#SilverLingua.Agent._use_tools","title":"_use_tools","text":"<pre><code>_use_tools(tool_calls: ToolCalls) -&gt; List[Notion]\n</code></pre> <p>Uses Tools based on the given ToolCalls, returning Notions containing ToolCallResponses.</p> <p>Parameters:</p> Name Type Description Default <code>tool_calls</code> <code>ToolCalls</code> <p>The ToolCalls to use.</p> required <p>Returns:</p> Type Description <code>List[Notion]</code> <p>List[Notion]: The Notions containing ToolCallResponses. Each Notion will have a role of ChatRole.TOOL_RESPONSE.</p> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>def _use_tools(self, tool_calls: ToolCalls) -&gt; List[Notion]:\n    \"\"\"\n    Uses Tools based on the given ToolCalls, returning Notions\n    containing ToolCallResponses.\n\n    Args:\n        tool_calls (ToolCalls): The ToolCalls to use.\n\n    Returns:\n        List[Notion]: The Notions containing ToolCallResponses.\n            Each Notion will have a role of ChatRole.TOOL_RESPONSE.\n    \"\"\"\n    responses: List[Notion] = []\n    for tool_call in tool_calls.list:\n        tool = self._find_tool(tool_call.function.name)\n        if tool is not None:\n            tc_function_response = {}\n            with contextlib.suppress(json.JSONDecodeError):\n                tc_function_response = json.loads(tool_call.function.arguments)\n\n            tc_response = ToolCallResponse.from_tool_call(\n                tool_call=tool_call, response=tool(**tc_function_response)\n            )\n            responses.append(\n                Notion(\n                    content=tc_response.model_dump_json(exclude_none=True),\n                    role=str(self.role.TOOL_RESPONSE.value),\n                )\n            )\n        else:\n            responses.append(\n                Notion(\n                    content=json.dumps(\n                        {\n                            \"tool_call_id\": tool_call.id,\n                            \"content\": \"Tool not found\",\n                            \"name\": \"error\",\n                        }\n                    ),\n                    role=str(self.role.TOOL_RESPONSE.value),\n                )\n            )\n    return responses\n</code></pre>"},{"location":"api/#SilverLingua.Agent._bind_tools","title":"_bind_tools","text":"<pre><code>_bind_tools() -&gt; None\n</code></pre> <p>Called at the end of init to bind the tools to the model.</p> <p>This MUST be redefined in subclasses to dictate how the tools are bound to the model.</p> <p>Example: <pre><code># From OpenAIChatAgent\ndef _bind_tools(self) -&gt; None:\n    m_tools: List[ChatCompletionToolParam] = [\n        {\"type\": \"function\", \"function\": tool.description}\n        for tool in self.tools\n    ]\n\n    if len(m_tools) &gt; 0:\n        self.model.tools = m_tools\n</code></pre></p> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>def _bind_tools(self) -&gt; None:\n    \"\"\"\n    Called at the end of __init__ to bind the tools to the model.\n\n    This MUST be redefined in subclasses to dictate how\n    the tools are bound to the model.\n\n    Example:\n    ```python\n    # From OpenAIChatAgent\n    def _bind_tools(self) -&gt; None:\n        m_tools: List[ChatCompletionToolParam] = [\n            {\"type\": \"function\", \"function\": tool.description}\n            for tool in self.tools\n        ]\n\n        if len(m_tools) &gt; 0:\n            self.model.tools = m_tools\n    ```\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/#SilverLingua.Agent.add_tool","title":"add_tool","text":"<pre><code>add_tool(tool: Tool) -&gt; None\n</code></pre> <p>Adds a tool to the agent.</p> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>def add_tool(self, tool: Tool) -&gt; None:\n    \"\"\"\n    Adds a tool to the agent.\n    \"\"\"\n    self.tools.append(tool)\n    self._bind_tools()\n</code></pre>"},{"location":"api/#SilverLingua.Agent.add_tools","title":"add_tools","text":"<pre><code>add_tools(tools: List[Tool]) -&gt; None\n</code></pre> <p>Adds a list of tools to the agent.</p> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>def add_tools(self, tools: List[Tool]) -&gt; None:\n    \"\"\"\n    Adds a list of tools to the agent.\n    \"\"\"\n    self.tools.extend(tools)\n    self._bind_tools()\n</code></pre>"},{"location":"api/#SilverLingua.Agent.remove_tool","title":"remove_tool","text":"<pre><code>remove_tool(name: str) -&gt; None\n</code></pre> <p>Removes a tool from the agent.</p> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>def remove_tool(self, name: str) -&gt; None:\n    \"\"\"\n    Removes a tool from the agent.\n    \"\"\"\n    for i, tool in enumerate(self.tools):\n        if tool.name == name:\n            self.tools.pop(i)\n            break\n    self._bind_tools()\n</code></pre>"},{"location":"api/#SilverLingua.Agent._process_messages","title":"_process_messages","text":"<pre><code>_process_messages(messages: Messages) -&gt; List[Notion]\n</code></pre> <p>Convert various message types into a list of Notions.</p> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>def _process_messages(self, messages: Messages) -&gt; List[Notion]:\n    \"\"\"Convert various message types into a list of Notions.\"\"\"\n    if isinstance(messages, str):\n        return [Notion(content=messages, role=str(self.role.HUMAN.value))]\n    elif isinstance(messages, Notion):\n        return [messages]\n    elif isinstance(messages, Idearium):\n        return messages.notions\n    elif isinstance(messages, list):\n        return [\n            (\n                Notion(content=msg, role=str(self.role.HUMAN.value))\n                if isinstance(msg, str)\n                else msg\n            )\n            for msg in messages\n        ]\n    raise ValueError(f\"Unsupported message type: {type(messages)}\")\n</code></pre>"},{"location":"api/#SilverLingua.Agent._process_generation","title":"_process_generation","text":"<pre><code>_process_generation(responses: List[Notion], is_async=False) -&gt; List[Notion]\n</code></pre> <p>Wrapper around shared logic between generate and agenerate.</p> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>def _process_generation(\n    self, responses: List[Notion], is_async=False\n) -&gt; List[Notion]:\n    \"\"\"Wrapper around shared logic between generate and agenerate.\"\"\"\n    response = responses[0]\n    # logger.debug(f\"Response: {response}\")\n    if response.chat_role == ChatRole.TOOL_CALL:\n        # logger.debug(\"Tool call detected\")\n        # Add the tool call to the idearium\n        self.idearium.append(response)\n        # Call generate again with the tool response\n        tool_calls = ToolCalls.model_validate_json(\n            '{\"list\": ' + response.content + \"}\"\n        )\n        tool_response = self._use_tools(tool_calls)\n        # logger.debug(f\"Tool response: {tool_response}\")\n        if is_async:\n            return self.agenerate(tool_response)\n        else:\n            return self.generate(tool_response)\n    else:\n        return responses\n</code></pre>"},{"location":"api/#SilverLingua.Agent.generate","title":"generate","text":"<pre><code>generate(messages: Messages, **kwargs) -&gt; List[Notion]\n</code></pre> <p>Generates a response to the given messages by calling the underlying model's generate method and checking/actualizing tool usage.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>Union[str, Notion, Idearium, List[Union[str, Notion]]]</code> required <p>Returns:</p> Type Description <code>List[Notion]</code> <p>List[Notion]: A list of responses to the given messages. (Many times there will only be one response.)</p> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>def generate(self, messages: Messages, **kwargs) -&gt; List[Notion]:\n    \"\"\"\n    Generates a response to the given messages by calling the\n    underlying model's generate method and checking/actualizing tool usage.\n\n    Args:\n        messages (Union[str, Notion, Idearium, List[Union[str, Notion]]]):\n        The messages to respond to.\n\n    Returns:\n        List[Notion]: A list of responses to the given messages.\n            (Many times there will only be one response.)\n    \"\"\"\n    self.idearium.extend(self._process_messages(messages))\n    responses = self.model.generate(self.idearium, **kwargs)\n    result = self._process_generation(responses)\n\n    if self.auto_append_response:\n        self.idearium.extend(result)\n\n    return result\n</code></pre>"},{"location":"api/#SilverLingua.Agent.agenerate","title":"agenerate  <code>async</code>","text":"<pre><code>agenerate(messages: Messages, **kwargs) -&gt; List[Notion]\n</code></pre> <p>Asynchronously generates a response to the given messages by calling the underlying model's agenerate method and checking/actualizing tool usage.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>Union[str, Notion, Idearium, List[Union[str, Notion]]]</code> required <p>Returns:</p> Type Description <code>List[Notion]</code> <p>List[Notion]: A list of responses to the given messages. (Many times there will only be one response.)</p> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>async def agenerate(self, messages: Messages, **kwargs) -&gt; List[Notion]:\n    \"\"\"\n    Asynchronously generates a response to the given messages by calling the\n    underlying model's agenerate method and checking/actualizing tool usage.\n\n    Args:\n        messages (Union[str, Notion, Idearium, List[Union[str, Notion]]]):\n        The messages to respond to.\n\n    Returns:\n        List[Notion]: A list of responses to the given messages.\n            (Many times there will only be one response.)\n    \"\"\"\n    self.idearium.extend(self._process_messages(messages))\n    responses = await self.model.agenerate(self.idearium, **kwargs)\n    result = self._process_generation(responses, True)\n    r = await result if asyncio.iscoroutine(result) else result\n\n    if self.auto_append_response:\n        self.idearium.extend(r)\n\n    return r\n</code></pre>"},{"location":"api/#SilverLingua.Agent._process_tool_calls","title":"_process_tool_calls","text":"<pre><code>_process_tool_calls(tool_calls: ToolCalls)\n</code></pre> <p>Processes tool calls and returns the tool response.</p> <p>Parameters:</p> Name Type Description Default <code>tool_calls</code> <code>ToolCalls</code> <p>The tool calls to process.</p> required <p>Returns:</p> Type Description <p>Optional[ToolCalls]: The tool response. If None, no tool calls were found.</p> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>def _process_tool_calls(self, tool_calls: ToolCalls):\n    \"\"\"\n    Processes tool calls and returns the tool response.\n\n    Args:\n        tool_calls (ToolCalls): The tool calls to process.\n\n    Returns:\n        Optional[ToolCalls]: The tool response. If None, no tool calls were found.\n    \"\"\"\n    for i, tool_call in enumerate(tool_calls.list):\n        if not tool_call.id.startswith(\"call_\"):\n            # Something went wrong and this tool call is not valid\n            tool_calls.list.pop(i)\n            logger.error(\n                \"Invalid tool call: \"\n                + f\"{tool_call.model_dump_json(exclude_none=True)}\"\n            )\n\n    tc_dump = tool_calls.model_dump(exclude_none=True)\n    if tc_dump.get(\"list\"):\n        logger.debug(f\"Tool calls: {tc_dump}\")\n\n        # Create a new notion from the tool calls\n        tc_notion = Notion(\n            content=json.dumps(tc_dump.get(\"list\")),\n            role=str(ChatRole.TOOL_CALL.value),\n        )\n\n        # Add the tool call to the idearium\n        self.idearium.append(tc_notion)\n        # Call stream again with the tool response\n        tool_response = self._use_tools(tool_calls)\n        return tool_response\n    else:\n        logger.error(\"No tool calls found\")\n        return None\n</code></pre>"},{"location":"api/#SilverLingua.Agent.stream","title":"stream","text":"<pre><code>stream(messages: Messages, **kwargs)\n</code></pre> <p>Streams a response to the given prompt by calling the underlying model's stream method and checking/actualizing tool usage.</p> <p>NOTE: Will raise an exception if the underlying model does not support streaming.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>Union[str, Notion, Idearium, List[Union[str, Notion]]]</code> required <p>Returns:</p> Type Description <p>Generator[Notion, Any, None]: A generator of responses to the given messages.</p> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>def stream(self, messages: Messages, **kwargs):\n    \"\"\"\n    Streams a response to the given prompt by calling the\n    underlying model's stream method and checking/actualizing tool usage.\n\n    NOTE: Will raise an exception if the underlying model does not support\n    streaming.\n\n    Args:\n        messages (Union[str, Notion, Idearium, List[Union[str, Notion]]]):\n        The messages to respond to.\n\n    Returns:\n        Generator[Notion, Any, None]: A generator of responses to the given\n            messages.\n    \"\"\"\n    self.idearium.extend(self._process_messages(messages))\n    response_stream = self.model.stream(self.idearium, **kwargs)\n\n    # Process stream directly\n    tool_calls: Optional[ToolCalls] = None\n\n    for r in response_stream:\n        if r.chat_role == ChatRole.TOOL_CALL:\n            logger.debug(f\"Tool call detected: {r.content}\")\n            tc_chunks = ToolCalls.model_validate_json('{\"list\": ' + r.content + \"}\")\n            tool_calls = tool_calls and tool_calls.concat(tc_chunks) or tc_chunks\n            continue\n        elif r.content is not None:\n            logger.debug(f\"Got chunk in stream: {r.content!r}\")\n            if self.auto_append_response:\n                self.idearium.append(r)\n            yield r\n\n    # Handle tool calls if any\n    if tool_calls is not None:\n        logger.debug(\"Moving to tool response stream\")\n        tool_response = self._process_tool_calls(tool_calls)\n        if tool_response is not None:\n            for r in self.stream(tool_response):\n                yield r\n</code></pre>"},{"location":"api/#SilverLingua.Agent.astream","title":"astream  <code>async</code>","text":"<pre><code>astream(messages: Messages, **kwargs)\n</code></pre> <p>Asynchronously streams a response to the given prompt by calling the underlying model's astream method and checking/actualizing tool usage.</p> <p>NOTE: Will raise an exception if the underlying model does not support streaming.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>Union[str, Notion, Idearium, List[Union[str, Notion]]]</code> required <p>Returns:</p> Type Description <p>Generator[Notion, Any, None]: A generator of responses to the given messages.</p> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>async def astream(self, messages: Messages, **kwargs):\n    \"\"\"\n    Asynchronously streams a response to the given prompt by calling the\n    underlying model's astream method and checking/actualizing tool usage.\n\n    NOTE: Will raise an exception if the underlying model does not support\n    streaming.\n\n    Args:\n        messages (Union[str, Notion, Idearium, List[Union[str, Notion]]]):\n        The messages to respond to.\n\n    Returns:\n        Generator[Notion, Any, None]: A generator of responses to the given\n            messages.\n    \"\"\"\n    self.idearium.extend(self._process_messages(messages))\n    response_stream = self.model.astream(self.idearium, **kwargs)\n\n    # Process stream directly\n    tool_calls: Optional[ToolCalls] = None\n\n    async for r in response_stream:\n        if r.chat_role == ChatRole.TOOL_CALL:\n            logger.debug(f\"Tool call detected: {r.content}\")\n            tc_chunks = ToolCalls.model_validate_json('{\"list\": ' + r.content + \"}\")\n            tool_calls = tool_calls and tool_calls.concat(tc_chunks) or tc_chunks\n            continue\n        elif r.content is not None:\n            logger.debug(f\"Got chunk in astream: {r.content!r}\")\n            if self.auto_append_response:\n                self.idearium.append(r)\n            yield r\n\n    # Handle tool calls if any\n    if tool_calls is not None:\n        logger.debug(\"Moving to tool response stream\")\n        tool_response = self._process_tool_calls(tool_calls)\n        if tool_response is not None:\n            async for r in self.astream(tool_response):\n                yield r\n</code></pre>"},{"location":"api/#SilverLingua.Model","title":"Model","text":"<p>               Bases: <code>BaseModel</code>, <code>ABC</code></p> <p>Abstract class for all Large Language Models.</p> <p>This class outlines a standardized lifecycle for interacting with LLMs, aimed at ensuring a consistent process for message trimming, pre-processing, preparing requests for the model, invoking the model, standardizing the response, and post-processing. The lifecycle is as follows:</p> Lifecycle <ol> <li> <p>Pre-processing (<code>_preprocess</code>): Performs any necessary transformations or     adjustments to the messages prior to trimming or preparing them for model input.     (Optional)</p> </li> <li> <p>Preparing Request (<code>_format_request</code>): Converts the pre-processed messages     into a format suitable for model input.</p> </li> <li> <p>Model Invocation (<code>_call</code> or <code>_acall</code>): Feeds the prepared input to the LLM and     retrieves the raw model output. There should be both synchronous and     asynchronous versions available.</p> </li> <li> <p>Standardizing Response (<code>_standardize_response</code>): Transforms the raw model     output into a consistent response format suitable for further processing or     delivery.</p> </li> <li> <p>Post-processing (<code>_postprocess</code>): Performs any final transformations or     adjustments to the standardized responses, making them ready for delivery.     (Optional)</p> </li> </ol> <p>Subclasses should implement each of the non-optional lifecycle steps in accordance with the specific requirements and behaviors of the target LLM.</p> See also <ul> <li><code>Agent</code></li> <li><code>Idearium</code></li> <li><code>Notion</code></li> </ul>"},{"location":"api/#SilverLingua.Model.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(frozen=True)\n</code></pre>"},{"location":"api/#SilverLingua.Model.max_response","title":"max_response  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_response: int = Field(default=0)\n</code></pre>"},{"location":"api/#SilverLingua.Model.api_key","title":"api_key  <code>instance-attribute</code>","text":"<pre><code>api_key: str\n</code></pre>"},{"location":"api/#SilverLingua.Model.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/#SilverLingua.Model.role","title":"role  <code>instance-attribute</code>","text":"<pre><code>role: Type[ChatRole]\n</code></pre>"},{"location":"api/#SilverLingua.Model.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: ModelType\n</code></pre>"},{"location":"api/#SilverLingua.Model.llm","title":"llm  <code>instance-attribute</code>","text":"<pre><code>llm: Callable\n</code></pre>"},{"location":"api/#SilverLingua.Model.llm_async","title":"llm_async  <code>instance-attribute</code>","text":"<pre><code>llm_async: Callable\n</code></pre>"},{"location":"api/#SilverLingua.Model.can_stream","title":"can_stream  <code>instance-attribute</code>","text":"<pre><code>can_stream: bool\n</code></pre>"},{"location":"api/#SilverLingua.Model.tokenizer","title":"tokenizer  <code>instance-attribute</code>","text":"<pre><code>tokenizer: Tokenizer\n</code></pre>"},{"location":"api/#SilverLingua.Model.max_tokens","title":"max_tokens  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>max_tokens: int\n</code></pre> <p>The maximum number of tokens that can be fed to the model at once.</p>"},{"location":"api/#SilverLingua.Model._process_input","title":"_process_input","text":"<pre><code>_process_input(messages: Messages) -&gt; Idearium\n</code></pre> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>def _process_input(self, messages: Messages) -&gt; Idearium:\n    if isinstance(messages, str):\n        notions = [Notion(content=messages, role=self.role.HUMAN)]\n    elif isinstance(messages, Notion):\n        notions = [messages]\n    elif isinstance(messages, Idearium):\n        return messages  # Already an Idearium, no need to convert\n    elif isinstance(messages, list):\n        notions = [\n            (\n                Notion(content=msg, role=self.role.HUMAN)\n                if isinstance(msg, str)\n                else msg\n            )\n            for msg in messages\n        ]\n    else:\n        raise ValueError(\"Invalid input type for messages\")\n\n    return Idearium(self.tokenizer, self.max_tokens, notions)\n</code></pre>"},{"location":"api/#SilverLingua.Model._convert_role","title":"_convert_role","text":"<pre><code>_convert_role(role: ChatRole) -&gt; str\n</code></pre> <p>Converts the standard ChatRole to the model-specific role.</p> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>def _convert_role(self, role: ChatRole) -&gt; str:\n    \"\"\"\n    Converts the standard ChatRole to the model-specific role.\n    \"\"\"\n    return str(self.role[role.name].value)\n</code></pre>"},{"location":"api/#SilverLingua.Model._preprocess","title":"_preprocess","text":"<pre><code>_preprocess(messages: List[Notion]) -&gt; List[Notion]\n</code></pre> <p>Preprocesses the List of <code>Notions</code>, applying any effects necessary before being prepped for input into an API.</p> <p>This is a lifecycle method that is called by the <code>generate</code> method.</p> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>def _preprocess(self, messages: List[Notion]) -&gt; List[Notion]:\n    \"\"\"\n    Preprocesses the List of `Notions`, applying any effects necessary\n    before being prepped for input into an API.\n\n    This is a lifecycle method that is called by the `generate` method.\n    \"\"\"\n    return [\n        Notion(msg.content, self._convert_role(msg.chat_role), msg.persistent)\n        for msg in messages\n    ]\n</code></pre>"},{"location":"api/#SilverLingua.Model._format_request","title":"_format_request  <code>abstractmethod</code>","text":"<pre><code>_format_request(messages: List[Notion], *args, **kwargs) -&gt; Union[str, object]\n</code></pre> <p>Formats the List of <code>Notions</code> into a format suitable for model input.</p> <p>This is a lifecycle method that is called by the <code>generate</code> method.</p> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>@abstractmethod\ndef _format_request(\n    self, messages: List[Notion], *args, **kwargs\n) -&gt; Union[str, object]:\n    \"\"\"\n    Formats the List of `Notions` into a format suitable for model input.\n\n    This is a lifecycle method that is called by the `generate` method.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/#SilverLingua.Model._standardize_response","title":"_standardize_response  <code>abstractmethod</code>","text":"<pre><code>_standardize_response(response: Union[object, str, List[any]], *args, **kwargs) -&gt; List[Notion]\n</code></pre> <p>Standardizes the raw response from the model into a List of Notions.</p> <p>This is a lifecycle method that is called by the <code>generate</code> method.</p> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>@abstractmethod\ndef _standardize_response(\n    self, response: Union[object, str, List[any]], *args, **kwargs\n) -&gt; List[Notion]:\n    \"\"\"\n    Standardizes the raw response from the model into a List of Notions.\n\n    This is a lifecycle method that is called by the `generate` method.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/#SilverLingua.Model._postprocess","title":"_postprocess  <code>abstractmethod</code>","text":"<pre><code>_postprocess(response: List[Notion], *args, **kwargs) -&gt; List[Notion]\n</code></pre> <p>Postprocesses the response from the model, applying any final effects before being returned.</p> <p>This is a lifecycle method that is called by the <code>generate</code> method.</p> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>@abstractmethod\ndef _postprocess(self, response: List[Notion], *args, **kwargs) -&gt; List[Notion]:\n    \"\"\"\n    Postprocesses the response from the model, applying any final effects\n    before being returned.\n\n    This is a lifecycle method that is called by the `generate` method.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/#SilverLingua.Model._retry_call","title":"_retry_call  <code>abstractmethod</code>","text":"<pre><code>_retry_call(input: Union[str, object, List[any]], e: Exception, api_call: Callable, retries: int = 0) -&gt; Union[str, object]\n</code></pre> <p>Retry logic for API calls used by <code>_common_call_logic</code>.</p> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>@abstractmethod\ndef _retry_call(\n    self,\n    input: Union[str, object, List[any]],\n    e: Exception,\n    api_call: Callable,\n    retries: int = 0,\n) -&gt; Union[str, object]:\n    \"\"\"\n    Retry logic for API calls used by `_common_call_logic`.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/#SilverLingua.Model._common_call_logic","title":"_common_call_logic","text":"<pre><code>_common_call_logic(input: Union[str, object, List[any]], api_call: Callable, retries: int = 0) -&gt; Union[str, object]\n</code></pre> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>def _common_call_logic(\n    self,\n    input: Union[str, object, List[any]],\n    api_call: Callable,\n    retries: int = 0,\n) -&gt; Union[str, object]:\n    if input is None:\n        raise ValueError(\"No input provided.\")\n\n    try:\n        out = api_call(messages=input)\n        return out\n    except Exception as e:\n        logger.error(f\"Error calling LLM API: {e}\")\n        if retries &gt;= 3:\n            raise e\n\n        return self._retry_call(input, e, api_call, retries=retries)\n</code></pre>"},{"location":"api/#SilverLingua.Model._call","title":"_call","text":"<pre><code>_call(input: Union[str, object, List[any]], retries: int = 0, **kwargs) -&gt; object\n</code></pre> <p>Calls the model with the given input and returns the raw response.</p> <p>Should behave exactly as <code>_acall</code> does, but synchronously.</p> <p>This is a lifecycle method that is called by the <code>generate</code> method.</p> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>def _call(\n    self, input: Union[str, object, List[any]], retries: int = 0, **kwargs\n) -&gt; object:\n    \"\"\"\n    Calls the model with the given input and returns the raw response.\n\n    Should behave exactly as `_acall` does, but synchronously.\n\n    This is a lifecycle method that is called by the `generate` method.\n    \"\"\"\n\n    def api_call(**kwargs_):\n        return self.llm(**kwargs_, **kwargs)\n\n    return self._common_call_logic(input, api_call, retries)\n</code></pre>"},{"location":"api/#SilverLingua.Model._acall","title":"_acall  <code>async</code>","text":"<pre><code>_acall(input: Union[str, object, List[any]], retries: int = 0, **kwargs) -&gt; object\n</code></pre> <p>Calls the model with the given input and returns the raw response asynchronously.</p> <p>Should behave exactly as <code>_call</code> does, but asynchronously.</p> <p>This is a lifecycle method that is called by the <code>agenerate</code> method.</p> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>async def _acall(\n    self, input: Union[str, object, List[any]], retries: int = 0, **kwargs\n) -&gt; object:\n    \"\"\"\n    Calls the model with the given input and returns the\n    raw response asynchronously.\n\n    Should behave exactly as `_call` does, but asynchronously.\n\n    This is a lifecycle method that is called by the `agenerate` method.\n    \"\"\"\n\n    async def api_call(**kwargs_):\n        return await self.llm_async(**kwargs_, **kwargs)\n\n    result = self._common_call_logic(input, api_call, retries)\n    if asyncio.iscoroutine(result):\n        return await result\n    return result\n</code></pre>"},{"location":"api/#SilverLingua.Model._common_generate_logic","title":"_common_generate_logic","text":"<pre><code>_common_generate_logic(messages: Messages, is_async=False, **kwargs)\n</code></pre> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>def _common_generate_logic(\n    self,\n    messages: Messages,\n    is_async=False,\n    **kwargs,\n):\n    if messages is None:\n        raise ValueError(\"No messages provided.\")\n\n    call_method = self._acall if is_async else self._call\n\n    idearium = self._process_input(messages)\n    input = self._format_request(self._preprocess(idearium))\n\n    if is_async:\n\n        async def call():\n            response = await call_method(input, **kwargs)\n            output = self._standardize_response(response)\n            return self._postprocess(output)\n\n        return call()\n    else:\n        response = call_method(input, **kwargs)\n        output = self._standardize_response(response)\n        return self._postprocess(output)\n</code></pre>"},{"location":"api/#SilverLingua.Model.generate","title":"generate  <code>abstractmethod</code>","text":"<pre><code>generate(messages: Messages, *args, **kwargs) -&gt; List[Notion]\n</code></pre> <p>Calls the model with the given messages and returns the response.</p> <p>Messages can be any of: string, list of strings, Notion, list of Notions, or Idearium.</p> <p>This is the primary method for generating responses from the model, and is responsible for calling all of the lifecycle methods.</p> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>@abstractmethod\ndef generate(\n    self,\n    messages: Messages,\n    *args,\n    **kwargs,\n) -&gt; List[Notion]:\n    \"\"\"\n    Calls the model with the given messages and returns the response.\n\n    Messages can be any of:\n    string, list of strings, Notion, list of Notions, or Idearium.\n\n    This is the primary method for generating responses from the model,\n    and is responsible for calling all of the lifecycle methods.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/#SilverLingua.Model.agenerate","title":"agenerate  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>agenerate(messages: Messages, *args, **kwargs) -&gt; List[Notion]\n</code></pre> <p>Calls the model with the given messages and returns the response asynchronously.</p> <p>Messages can be any of: string, list of strings, Notion, list of Notions, or Idearium.</p> <p>This is the primary method for generating async responses from the model, and is responsible for calling all of the lifecycle methods.</p> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>@abstractmethod\nasync def agenerate(\n    self,\n    messages: Messages,\n    *args,\n    **kwargs,\n) -&gt; List[Notion]:\n    \"\"\"\n    Calls the model with the given messages and returns the response\n    asynchronously.\n\n    Messages can be any of:\n    string, list of strings, Notion, list of Notions, or Idearium.\n\n    This is the primary method for generating async responses from the model,\n    and is responsible for calling all of the lifecycle methods.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/#SilverLingua.Model._common_stream_logic","title":"_common_stream_logic","text":"<pre><code>_common_stream_logic(messages: Messages)\n</code></pre> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>def _common_stream_logic(self, messages: Messages):\n    if messages is None:\n        raise ValueError(\"No messages provided.\")\n\n    if not self.can_stream:\n        raise ValueError(\n            \"This model does not support streaming. \"\n            + \"Please use the `generate` method instead.\"\n        )\n\n    idearium = self._process_input(messages)\n    input = self._format_request(self._preprocess(idearium))\n    return input\n</code></pre>"},{"location":"api/#SilverLingua.Model.stream","title":"stream  <code>abstractmethod</code>","text":"<pre><code>stream(messages: Messages, *args, **kwargs) -&gt; Generator[Notion, Any, None]\n</code></pre> <p>Streams the model with the given messages and returns the response, one token at a time.</p> <p>Messages can be any of: string, list of strings, Notion, list of Notions, or Idearium.</p> <p>If the model cannot be streamed, this will raise an exception.</p> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>@abstractmethod\ndef stream(\n    self, messages: Messages, *args, **kwargs\n) -&gt; Generator[Notion, Any, None]:\n    \"\"\"\n    Streams the model with the given messages and returns the response,\n    one token at a time.\n\n    Messages can be any of:\n    string, list of strings, Notion, list of Notions, or Idearium.\n\n    If the model cannot be streamed, this will raise an exception.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/#SilverLingua.Model.astream","title":"astream  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>astream(messages: Messages, *args, **kwargs) -&gt; Generator[Notion, Any, None]\n</code></pre> <p>Streams the model with the given messages and returns the response, one token at a time, asynchronously.</p> <p>Messages can be any of: string, list of strings, Notion, list of Notions, or Idearium.</p> <p>If the model cannot be streamed, this will raise an exception.</p> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>@abstractmethod\nasync def astream(\n    self, messages: Messages, *args, **kwargs\n) -&gt; Generator[Notion, Any, None]:\n    \"\"\"\n    Streams the model with the given messages and returns the response,\n    one token at a time, asynchronously.\n\n    Messages can be any of:\n    string, list of strings, Notion, list of Notions, or Idearium.\n\n    If the model cannot be streamed, this will raise an exception.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/config/","title":"config","text":""},{"location":"api/config/#SilverLingua.config","title":"config","text":""},{"location":"api/config/#SilverLingua.config.Module","title":"Module","text":"<pre><code>Module(name: str, description: str, version: str, tools: List[Tool], chat_roles: List[type[ChatRole]], react_roles: List[type[ReactRole]], **kwargs)\n</code></pre> <p>               Bases: <code>BaseModel</code></p> <p>A module that can be loaded into SilverLingua.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the module.</p> <code>description</code> <code>str</code> <p>A description of the module.</p> <code>version</code> <code>str</code> <p>The version of the module.</p> <code>tools</code> <code>List[Tool]</code> <p>The tools in the module.</p> <code>chat_roles</code> <code>List[type[ChatRole]]</code> <p>The chat roles in the module.</p> <code>react_roles</code> <code>List[type[ReactRole]]</code> <p>The react roles in the module.</p> Source code in <code>src/SilverLingua/config.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    description: str,\n    version: str,\n    tools: List[Tool],\n    chat_roles: List[type[ChatRole]],\n    react_roles: List[type[ReactRole]],\n    **kwargs,\n):\n    super().__init__(\n        name=name,\n        description=description,\n        version=version,\n        tools=tools,\n        chat_roles=chat_roles,\n        react_roles=react_roles,\n        **kwargs,\n    )\n\n    Config.register_module(self)\n</code></pre>"},{"location":"api/config/#SilverLingua.config.Module.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/config/#SilverLingua.config.Module.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str\n</code></pre>"},{"location":"api/config/#SilverLingua.config.Module.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: str\n</code></pre>"},{"location":"api/config/#SilverLingua.config.Module.tools","title":"tools  <code>instance-attribute</code>","text":"<pre><code>tools: List[Tool]\n</code></pre>"},{"location":"api/config/#SilverLingua.config.Module.chat_roles","title":"chat_roles  <code>instance-attribute</code>","text":"<pre><code>chat_roles: List[type[ChatRole]]\n</code></pre>"},{"location":"api/config/#SilverLingua.config.Module.react_roles","title":"react_roles  <code>instance-attribute</code>","text":"<pre><code>react_roles: List[type[ReactRole]]\n</code></pre>"},{"location":"api/config/#SilverLingua.config.Module.check_chat_roles","title":"check_chat_roles","text":"<pre><code>check_chat_roles(v)\n</code></pre> Source code in <code>src/SilverLingua/config.py</code> <pre><code>@field_validator(\"chat_roles\", mode=\"plain\")\ndef check_chat_roles(cls, v):\n    for role in v:\n        if not issubclass(role, Enum):\n            raise TypeError(\"Expected an enum\")\n        else:\n            for member in role:\n                if (\n                    not ChatRole[member.name]\n                    or member.value != ChatRole[member.name].value\n                ):\n                    raise TypeError(\"members must match ChatRole members.\")\n    return v\n</code></pre>"},{"location":"api/config/#SilverLingua.config.Module.check_react_roles","title":"check_react_roles","text":"<pre><code>check_react_roles(v)\n</code></pre> Source code in <code>src/SilverLingua/config.py</code> <pre><code>@field_validator(\"react_roles\", mode=\"plain\")\ndef check_react_roles(cls, v):\n    for role in v:\n        if not issubclass(role, Enum):\n            raise TypeError(\"Expected an enum\")\n        else:\n            for member in role:\n                if (\n                    not ReactRole[member.name]\n                    or member.value != ReactRole[member.name].value\n                ):\n                    raise TypeError(\"members must match ReactRole members.\")\n    return v\n</code></pre>"},{"location":"api/config/#SilverLingua.config.Config","title":"Config","text":""},{"location":"api/config/#SilverLingua.config.Config.modules","title":"modules  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>modules: List[Module] = []\n</code></pre>"},{"location":"api/config/#SilverLingua.config.Config.chat_roles","title":"chat_roles  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>chat_roles: List[type[ChatRole]] = [ChatRole]\n</code></pre>"},{"location":"api/config/#SilverLingua.config.Config.react_roles","title":"react_roles  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>react_roles: List[type[ReactRole]] = [ReactRole]\n</code></pre>"},{"location":"api/config/#SilverLingua.config.Config.tools","title":"tools  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tools: List[Tool] = []\n</code></pre>"},{"location":"api/config/#SilverLingua.config.Config.get_chat_role","title":"get_chat_role  <code>classmethod</code>","text":"<pre><code>get_chat_role(role: str) -&gt; Optional[ChatRole]\n</code></pre> <p>Attempts to get the standardized ChatRole enum from 'role'. If not, returns None.</p> <p>This is usually used internally for maintaining consistency in Notions across different LLM backends.</p> Source code in <code>src/SilverLingua/config.py</code> <pre><code>@classmethod\ndef get_chat_role(self, role: str) -&gt; Optional[ChatRole]:\n    \"\"\"\n    Attempts to get the standardized ChatRole enum from 'role'.\n    If not, returns None.\n\n    This is usually used internally for maintaining\n    consistency in Notions across different LLM backends.\n    \"\"\"\n    for enum_class in self.chat_roles:\n        for enum_member in enum_class:\n            if str(enum_member.value).lower() == str(role).lower():\n                return ChatRole[enum_member.name]\n    return None\n</code></pre>"},{"location":"api/config/#SilverLingua.config.Config.get_react_role","title":"get_react_role  <code>classmethod</code>","text":"<pre><code>get_react_role(role: str) -&gt; Optional[ReactRole]\n</code></pre> <p>Attempts to get the standardized ReactRole enum from 'role'. If not, returns None.</p> <p>This is usually used internally for maintaining consistency in Notions across different LLM backends.</p> Source code in <code>src/SilverLingua/config.py</code> <pre><code>@classmethod\ndef get_react_role(self, role: str) -&gt; Optional[ReactRole]:\n    \"\"\"\n    Attempts to get the standardized ReactRole enum from 'role'.\n    If not, returns None.\n\n    This is usually used internally for maintaining\n    consistency in Notions across different LLM backends.\n    \"\"\"\n    for enum_class in self.react_roles:\n        for enum_member in enum_class:\n            if enum_member.value == role:\n                return ReactRole[enum_member.name]\n    return None\n</code></pre>"},{"location":"api/config/#SilverLingua.config.Config.get_tool","title":"get_tool  <code>classmethod</code>","text":"<pre><code>get_tool(name: str) -&gt; Optional[Tool]\n</code></pre> <p>Attempts to get the tool with the given name. If not, returns None.</p> Source code in <code>src/SilverLingua/config.py</code> <pre><code>@classmethod\ndef get_tool(self, name: str) -&gt; Optional[Tool]:\n    \"\"\"\n    Attempts to get the tool with the given name.\n    If not, returns None.\n    \"\"\"\n    for tool in self.tools:\n        if tool.name == name:\n            return tool\n    return None\n</code></pre>"},{"location":"api/config/#SilverLingua.config.Config.add_tool","title":"add_tool  <code>classmethod</code>","text":"<pre><code>add_tool(tool: Tool) -&gt; None\n</code></pre> <p>Adds a tool to the config.</p> Source code in <code>src/SilverLingua/config.py</code> <pre><code>@classmethod\ndef add_tool(self, tool: Tool) -&gt; None:\n    \"\"\"\n    Adds a tool to the config.\n    \"\"\"\n    self.tools.append(tool)\n</code></pre>"},{"location":"api/config/#SilverLingua.config.Config.add_chat_role","title":"add_chat_role  <code>classmethod</code>","text":"<pre><code>add_chat_role(role: Type[Enum]) -&gt; None\n</code></pre> <p>Adds a chat role to the config.</p> Source code in <code>src/SilverLingua/config.py</code> <pre><code>@classmethod\ndef add_chat_role(self, role: Type[Enum]) -&gt; None:\n    \"\"\"\n    Adds a chat role to the config.\n    \"\"\"\n    if not issubclass(role, Enum):\n        raise TypeError(\"Expected an enum\")\n    self.chat_roles.append(role)\n</code></pre>"},{"location":"api/config/#SilverLingua.config.Config.add_react_role","title":"add_react_role  <code>classmethod</code>","text":"<pre><code>add_react_role(role: Type[Enum]) -&gt; None\n</code></pre> <p>Adds a react role to the config.</p> Source code in <code>src/SilverLingua/config.py</code> <pre><code>@classmethod\ndef add_react_role(self, role: Type[Enum]) -&gt; None:\n    \"\"\"\n    Adds a react role to the config.\n    \"\"\"\n    if not issubclass(role, Enum):\n        raise TypeError(\"Expected an enum\")\n    self.react_roles.append(role)\n</code></pre>"},{"location":"api/config/#SilverLingua.config.Config.register_module","title":"register_module  <code>classmethod</code>","text":"<pre><code>register_module(module: Module) -&gt; None\n</code></pre> <p>Registers a module.</p> Source code in <code>src/SilverLingua/config.py</code> <pre><code>@classmethod\ndef register_module(self, module: Module) -&gt; None:\n    \"\"\"\n    Registers a module.\n    \"\"\"\n    self.modules.append(module)\n    for tool in module.tools:\n        self.add_tool(tool)\n    for chat_role in module.chat_roles:\n        self.add_chat_role(chat_role)\n    for react_role in module.react_roles:\n        self.add_react_role(react_role)\n\n    logger.debug(\n        f'Registered module {module.name}@{module.version}: \"{module.description}\"'\n    )\n</code></pre>"},{"location":"api/core/atoms/","title":"index","text":""},{"location":"api/core/atoms/#SilverLingua.core.atoms","title":"atoms","text":"<p>Atoms are the fundamental, indivisible building blocks of SilverLingua. They represent  single-purpose, foundational components that can't be broken down further while remaining useful.</p> <p>See Design Principles - Atoms for more details.</p>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.Memory","title":"Memory","text":"<p>               Bases: <code>BaseModel</code></p> <p>A Memory is the smallest unit of storage information, and is the base class for all other storage information like <code>Notion</code>.</p>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.Memory.content","title":"content  <code>instance-attribute</code>","text":"<pre><code>content: str\n</code></pre>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.ChatRole","title":"ChatRole","text":"<p>               Bases: <code>Enum</code></p> <p>Standardized roles for chat messages.</p> Warning <p>Do not instantiate this enum directly. Use <code>create_chat_role()</code> instead.</p>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.ChatRole.SYSTEM","title":"SYSTEM  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SYSTEM = RoleMember('SYSTEM', 'SYSTEM')\n</code></pre>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.ChatRole.HUMAN","title":"HUMAN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HUMAN = RoleMember('HUMAN', 'HUMAN')\n</code></pre>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.ChatRole.AI","title":"AI  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AI = RoleMember('AI', 'AI')\n</code></pre>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.ChatRole.TOOL_CALL","title":"TOOL_CALL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TOOL_CALL = RoleMember('TOOL_CALL', 'TOOL_CALL')\n</code></pre>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.ChatRole.TOOL_RESPONSE","title":"TOOL_RESPONSE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TOOL_RESPONSE = RoleMember('TOOL_RESPONSE', 'TOOL_RESPONSE')\n</code></pre>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.ReactRole","title":"ReactRole","text":"<p>               Bases: <code>Enum</code></p> <p>Standardized roles for ReAct framework to help with chain-of-thought prompting.</p> <p>See: https://www.promptingguide.ai/techniques/react</p> Warning <p>Do not instantiate this enum directly. Use <code>create_react_role()</code> instead.</p>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.ReactRole.QUESTION","title":"QUESTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>QUESTION = RoleMember('QUESTION', 'QUESTION')\n</code></pre>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.ReactRole.THOUGHT","title":"THOUGHT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>THOUGHT = RoleMember('THOUGHT', 'THOUGHT')\n</code></pre>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.ReactRole.ACTION","title":"ACTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTION = RoleMember('ACTION', 'ACTION')\n</code></pre>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.ReactRole.OBSERVATION","title":"OBSERVATION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OBSERVATION = RoleMember('OBSERVATION', 'OBSERVATION')\n</code></pre>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.ReactRole.ANSWER","title":"ANSWER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ANSWER = RoleMember('ANSWER', 'ANSWER')\n</code></pre>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.Tokenizer","title":"Tokenizer","text":"<p>               Bases: <code>BaseModel</code></p> <p>A tokenizer that can encode and decode strings.</p>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.Tokenizer.encode","title":"encode  <code>instance-attribute</code>","text":"<pre><code>encode: Callable[[str], List[int]]\n</code></pre>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.Tokenizer.decode","title":"decode  <code>instance-attribute</code>","text":"<pre><code>decode: Callable[[List[int]], str]\n</code></pre>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.FunctionJSONSchema","title":"FunctionJSONSchema","text":"<p>               Bases: <code>BaseModel</code></p> <p>A function according to JSON schema standards.</p> <p>This is also passed in to OpenAI ChatCompletion API functions list so the AI understands how to call a function.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the function</p> <code>description</code> <code>str</code> <p>A description of the function</p> <code>parameters</code> <code>Parameters</code> <p>A dictionary of parameters and their types (Optional)</p> <p>Example:</p> <pre><code>{\n    \"name\": \"roll_dice\",\n    \"description\": \"Rolls a number of dice with a given number of sides, optionally\n        with a modifier and/or advantage/disadvantage.\n        Returns `{result: int, rolls: int[]}`\",\n    \"parameters\": {\n        \"type\": \"object\",\n        \"properties\": {\n            \"sides\": {\n              \"description\": \"The number of sides on each die\",\n              \"type\": \"integer\"\n            },\n            \"dice\": {\n              \"description\": \"The number of dice to roll (default 1)\",\n              \"type\": \"integer\"\n            },\n            \"modifier\": {\n              \"description\": \"The modifier to add to the roll total (default 0)\",\n              \"type\": \"integer\"\n            },\n            \"advantage\": {\n              \"description\": \"Whether to roll with advantage (default False)\",\n              \"type\": \"boolean\"\n            },\n            \"disadvantage\": {\n              \"description\": \"Whether to roll with disadvantage (default False)\",\n              \"type\": \"boolean\"\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.FunctionJSONSchema.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.FunctionJSONSchema.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str\n</code></pre>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.FunctionJSONSchema.parameters","title":"parameters  <code>instance-attribute</code>","text":"<pre><code>parameters: Parameters\n</code></pre>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.Tool","title":"Tool","text":"<pre><code>Tool(function: Callable)\n</code></pre> <p>               Bases: <code>BaseModel</code></p> <p>A wrapper class for functions that allows them to be both directly callable and serializable to JSON for use with an LLM.</p> <p>Attributes:</p> Name Type Description <code>function</code> <code>Callable</code> <p>The function to be wrapped.</p> <code>description</code> <code>FunctionJSONSchema</code> <p>A TypedDict that describes the function according to JSON schema standards.</p> <code>name</code> <code>str</code> <p>The name of the function, extracted from the FunctionJSONSchema.</p> See also <ul> <li><code>Agent</code></li> <li><code>Model</code></li> </ul> Example <pre><code>def my_function(x, y):\n    return x + y\n\n# Create a Tool instance\ntool_instance = Tool(my_function)\n\n# Directly call the wrapped function\nresult = tool_instance(1, 2)  # Output will be 3\n\n# Serialize to JSON\nserialized = str(tool_instance)\n\n####\n# Alternatively, you can use the decorator to turn a function into a Tool.\n####\n\n@tool\ndef my_function(x, y):\n    return x + y\n\n# Now the function itself is already a Tool.\nresult = my_function(1, 2)  # Output will be 3\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Callable</code> <p>The function to be turned into a Tool.</p> required Source code in <code>src/SilverLingua/core/atoms/tool/tool.py</code> <pre><code>def __init__(self, function: Callable):\n    \"\"\"\n    Args:\n        function (Callable): The function to be turned into a Tool.\n    \"\"\"\n    description = generate_function_json(function)\n    name = description.name\n    super().__init__(function=function, description=description, name=name)\n</code></pre>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.Tool.function","title":"function  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>function: Callable = Field(exclude=True)\n</code></pre>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.Tool.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: FunctionJSONSchema = Field(validate_default=True)\n</code></pre>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.Tool.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = Field(validate_default=True)\n</code></pre>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.Tool.use_function_call","title":"use_function_call","text":"<pre><code>use_function_call(function_call: ToolCallFunction)\n</code></pre> <p>Uses a FunctionCall to call the function.</p> Source code in <code>src/SilverLingua/core/atoms/tool/tool.py</code> <pre><code>def use_function_call(self, function_call: ToolCallFunction):\n    \"\"\"\n    Uses a FunctionCall to call the function.\n    \"\"\"\n    arguments_dict = function_call.arguments\n    if arguments_dict == \"\":\n        return json.dumps(self.function())\n\n    try:\n        arguments_dict = json.loads(function_call.arguments)\n    except json.JSONDecodeError:\n        raise ValueError(\n            \"ToolCall.arguments must be a JSON string.\\n\"\n            + f\"function_call.arguments: {function_call.arguments}\\n\"\n            + f\"json.loads result: {arguments_dict}\"\n        ) from None\n\n    return json.dumps(self.function(**arguments_dict))\n</code></pre>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.ToolCall","title":"ToolCall","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.ToolCall.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(extra='allow', ignored_types=(type(None)))\n</code></pre>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.ToolCall.function","title":"function  <code>instance-attribute</code>","text":"<pre><code>function: ToolCallFunction\n</code></pre>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.ToolCall.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = Field(default_factory=lambda: str(uuid4()))\n</code></pre>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.ToolCall.index","title":"index  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>index: Optional[int] = None\n</code></pre>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.ToolCall.string_if_none","title":"string_if_none","text":"<pre><code>string_if_none(v)\n</code></pre> Source code in <code>src/SilverLingua/core/atoms/tool/util.py</code> <pre><code>@field_validator(\"id\", mode=\"before\")\ndef string_if_none(cls, v):\n    return v if v is not None else str(uuid4())\n</code></pre>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.ToolCall.concat","title":"concat","text":"<pre><code>concat(other: ToolCall) -&gt; ToolCall\n</code></pre> <p>Concatenates two tool calls and returns the result.</p> <p>If the IDs are different, prioritize the ID of 'self'. For 'function', merge the 'name' and 'arguments' fields.</p> <p>We will prefer the <code>id</code> of self over other for 2 reasons: 1. We assume that self is the older of the two 2. The newer may be stream chunked, in which case the <code>id</code> of <code>other</code> may have been <code>None</code> and generated using UUID, but the older ID likely was generated by an API and thus this newer ID is not the true ID.</p> Source code in <code>src/SilverLingua/core/atoms/tool/util.py</code> <pre><code>def concat(self, other: \"ToolCall\") -&gt; \"ToolCall\":\n    \"\"\"\n    Concatenates two tool calls and returns the result.\n\n    If the IDs are different, prioritize the ID of 'self'.\n    For 'function', merge the 'name' and 'arguments' fields.\n\n    We will prefer the `id` of self over other for 2 reasons:\n    1. We assume that self is the older of the two\n    2. The newer may be stream chunked, in which case\n    the `id` of `other` may have been `None` and generated\n    using UUID, but the older ID likely was generated\n    by an API and thus this newer ID is not the true ID.\n    \"\"\"\n    merged_function = {\n        \"name\": self.function.name or other.function.name,\n        \"arguments\": (self.function.arguments or \"\")\n        + (other.function.arguments or \"\"),\n    }\n    merged_function = ToolCallFunction(**merged_function)\n\n    self_extra = self.__pydantic_extra__\n    other_extra = other.__pydantic_extra__\n\n    index = self.index if self.index is not None else other.index\n\n    # Compare the two extra fields\n    if self_extra != other_extra:\n        if not self_extra or not other_extra:\n            return ToolCall(\n                id=(self.id) or other.id,\n                function=merged_function,\n                index=index,\n                **(self_extra or {}),\n                **(other_extra or {}),\n            )\n        # If they are different, merge them\n        merged_extra = {}\n        for key in set(self_extra.keys()) | set(other_extra.keys()):\n            if key in self_extra and key in other_extra:\n                # If one is None, use the other\n                # Else, concatenate them\n                if self_extra[key] == other_extra[key]:\n                    merged_extra[key] = self_extra[key]\n                else:\n                    if self_extra[key] is None or other_extra[key] is None:\n                        merged_extra[key] = self_extra[key] or other_extra[key]\n                    else:\n                        merged_extra[key] = self_extra[key] + other_extra[key]\n            elif key in self_extra:\n                merged_extra[key] = self_extra[key]\n            elif key in other_extra:\n                merged_extra[key] = other_extra[key]\n        #\n        return ToolCall(\n            id=self.id or other.id,\n            function=merged_function,\n            index=index,\n            **merged_extra,\n        )\n\n    return ToolCall(\n        id=self.id or other.id,\n        function=merged_function,\n        index=index,\n        **(self_extra or {}),\n    )\n</code></pre>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.ToolCallFunction","title":"ToolCallFunction","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.ToolCallFunction.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = Field(default='')\n</code></pre>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.ToolCallFunction.arguments","title":"arguments  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>arguments: str = Field(default='')\n</code></pre>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.ToolCallFunction.string_if_none","title":"string_if_none","text":"<pre><code>string_if_none(v)\n</code></pre> Source code in <code>src/SilverLingua/core/atoms/tool/util.py</code> <pre><code>@field_validator(\"*\", mode=\"before\")\ndef string_if_none(cls, v):\n    return v if v is not None else \"\"\n</code></pre>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.ToolCallResponse","title":"ToolCallResponse","text":"<p>               Bases: <code>BaseModel</code></p> <p>The response property of a tool call.</p>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.ToolCallResponse.tool_call_id","title":"tool_call_id  <code>instance-attribute</code>","text":"<pre><code>tool_call_id: str\n</code></pre>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.ToolCallResponse.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.ToolCallResponse.content","title":"content  <code>instance-attribute</code>","text":"<pre><code>content: str\n</code></pre>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.ToolCallResponse.from_tool_call","title":"from_tool_call  <code>classmethod</code>","text":"<pre><code>from_tool_call(tool_call: ToolCall, response: str) -&gt; ToolCallResponse\n</code></pre> Source code in <code>src/SilverLingua/core/atoms/tool/util.py</code> <pre><code>@classmethod\ndef from_tool_call(cls, tool_call: \"ToolCall\", response: str) -&gt; \"ToolCallResponse\":\n    return cls(\n        tool_call_id=tool_call.id,\n        name=tool_call.function.name,\n        content=response,\n    )\n</code></pre>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.ToolCalls","title":"ToolCalls","text":"<p>               Bases: <code>BaseModel</code></p> <p>A list of tool calls.</p>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.ToolCalls.list","title":"list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>list: List[ToolCall] = Field(default_factory=list, frozen=True)\n</code></pre>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.ToolCalls.concat","title":"concat","text":"<pre><code>concat(other: ToolCalls) -&gt; ToolCalls\n</code></pre> <p>Concatenates two tool calls lists and returns the result.</p> Source code in <code>src/SilverLingua/core/atoms/tool/util.py</code> <pre><code>def concat(self, other: \"ToolCalls\") -&gt; \"ToolCalls\":\n    \"\"\"\n    Concatenates two tool calls lists and returns the result.\n    \"\"\"\n    new: List[ToolCall] = self.list.copy()\n    for tool_call in other.list:\n        found = False\n        # Find the tool call with the same ID\n        for i, self_tool_call in enumerate(new):\n            if (\n                self_tool_call.id == tool_call.id\n                or self_tool_call.index == tool_call.index\n            ):\n                new[i] = self_tool_call.concat(tool_call)\n                found = True\n        if not found:\n            new.append(tool_call)\n    return ToolCalls(list=new)\n</code></pre>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.RolePrompt","title":"RolePrompt","text":"<pre><code>RolePrompt(role: str, text: str)\n</code></pre> <p>{{ role }}: {{ text }}</p> Source code in <code>src/SilverLingua/core/atoms/prompt.py</code> <pre><code>@prompt\ndef RolePrompt(role: str, text: str):  # type: ignore\n    \"\"\"{{ role }}: {{ text }}\"\"\"\n</code></pre>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.create_chat_role","title":"create_chat_role","text":"<pre><code>create_chat_role(name: str, SYSTEM: str, HUMAN: str, AI: str, TOOL_CALL: str, TOOL_RESPONSE: str) -&gt; Type[ChatRole]\n</code></pre> <p>Create a new ChatRole enum with only the values of the RoleMembers changed.</p> <p>This will ensure that the parent of each member is ChatRole, which means that the members will be equal to the members of ChatRole.</p> Example <pre><code>OpenAIChatRole = create_chat_role(\n    \"OpenAIChatRole\",\n    SYSTEM=\"system\",\n    HUMAN=\"user\",\n    AI=\"assistant\",\n    TOOL_CALL=\"function_call\",\n    TOOL_RESPONSE=\"function\",\n)\n\nassert OpenAIChatRole.SYSTEM == ChatRole.SYSTEM # True\n</code></pre> Source code in <code>src/SilverLingua/core/atoms/role/chat.py</code> <pre><code>def create_chat_role(\n    name: str, SYSTEM: str, HUMAN: str, AI: str, TOOL_CALL: str, TOOL_RESPONSE: str\n) -&gt; Type[ChatRole]:\n    \"\"\"\n    Create a new ChatRole enum with only the values of the RoleMembers changed.\n\n    This will ensure that the parent of each member is ChatRole, which means\n    that the members will be equal to the members of ChatRole.\n\n    Example:\n        ```python\n        OpenAIChatRole = create_chat_role(\n            \"OpenAIChatRole\",\n            SYSTEM=\"system\",\n            HUMAN=\"user\",\n            AI=\"assistant\",\n            TOOL_CALL=\"function_call\",\n            TOOL_RESPONSE=\"function\",\n        )\n\n        assert OpenAIChatRole.SYSTEM == ChatRole.SYSTEM # True\n        ```\n    \"\"\"\n    return Enum(\n        name,\n        {\n            \"SYSTEM\": RoleMember(\"SYSTEM\", SYSTEM, ChatRole),\n            \"HUMAN\": RoleMember(\"HUMAN\", HUMAN, ChatRole),\n            \"AI\": RoleMember(\"AI\", AI, ChatRole),\n            \"TOOL_CALL\": RoleMember(\"TOOL_CALL\", TOOL_CALL, ChatRole),\n            \"TOOL_RESPONSE\": RoleMember(\"TOOL_RESPONSE\", TOOL_RESPONSE, ChatRole),\n        },\n    )\n</code></pre>"},{"location":"api/core/atoms/#SilverLingua.core.atoms.create_react_role","title":"create_react_role","text":"<pre><code>create_react_role(name: str, QUESTION: str, THOUGHT: str, ACTION: str, OBSERVATION: str, ANSWER: str) -&gt; Type[ReactRole]\n</code></pre> Source code in <code>src/SilverLingua/core/atoms/role/react.py</code> <pre><code>def create_react_role(\n    name: str,\n    QUESTION: str,\n    THOUGHT: str,\n    ACTION: str,\n    OBSERVATION: str,\n    ANSWER: str,\n) -&gt; Type[ReactRole]:\n    return Enum(\n        name,\n        {\n            \"QUESTION\": RoleMember(\"QUESTION\", QUESTION, ReactRole),\n            \"THOUGHT\": RoleMember(\"THOUGHT\", THOUGHT, ReactRole),\n            \"ACTION\": RoleMember(\"ACTION\", ACTION, ReactRole),\n            \"OBSERVATION\": RoleMember(\"OBSERVATION\", OBSERVATION, ReactRole),\n            \"ANSWER\": RoleMember(\"ANSWER\", ANSWER, ReactRole),\n        },\n    )\n</code></pre>"},{"location":"api/core/atoms/memory/","title":"Memory","text":""},{"location":"api/core/atoms/memory/#SilverLingua.core.atoms.memory","title":"memory","text":""},{"location":"api/core/atoms/memory/#SilverLingua.core.atoms.memory.Memory","title":"Memory","text":"<p>               Bases: <code>BaseModel</code></p> <p>A Memory is the smallest unit of storage information, and is the base class for all other storage information like <code>Notion</code>.</p>"},{"location":"api/core/atoms/memory/#SilverLingua.core.atoms.memory.Memory.content","title":"content  <code>instance-attribute</code>","text":"<pre><code>content: str\n</code></pre>"},{"location":"api/core/atoms/prompt/","title":"Prompt","text":""},{"location":"api/core/atoms/prompt/#SilverLingua.core.atoms.prompt","title":"prompt","text":""},{"location":"api/core/atoms/prompt/#SilverLingua.core.atoms.prompt.prompt","title":"prompt","text":"<pre><code>prompt(func: Callable) -&gt; Callable[..., str]\n</code></pre> <p>A decorator to render a function's docstring as a Jinja2 template. Uses the function arguments as variables for the template.</p> <p>Note: Be deliberate about new lines in your docstrings - they may make meaningful changes in an AI's output. For instance, separating long sentences with a newline for human readability may cause issues.</p> <p>Example Usage: <pre><code>@prompt\ndef fruit_prompt(fruits: list) -&gt; None:\n    \"\"\"\n    You are a helpful assistant that takes a list of fruit and gives information about their nutrition.\n\n    LIST OF FRUIT:\n    {% for fruit in fruits %}{{ fruit }}\n    {% endfor %}\n    \"\"\"\n\nprint(fruit_prompt([\"apple\", \"orange\"]))\n</code></pre></p> <p>Expected Output: <pre><code>You are a helpful assistant that takes a list of fruit and gives information about their nutrition.\n\nLIST OF FRUIT:\napple\norange\n</code></pre></p> Source code in <code>src/SilverLingua/core/atoms/prompt.py</code> <pre><code>def prompt(func: Callable) -&gt; Callable[..., str]:\n    \"\"\"\n    A decorator to render a function's docstring as a Jinja2 template.\n    Uses the function arguments as variables for the template.\n\n    Note: Be deliberate about new lines in your docstrings - they\n    may make meaningful changes in an AI's output. For instance,\n    separating long sentences with a newline for human\n    readability may cause issues.\n\n    Example Usage:\n    ```python\n    @prompt\n    def fruit_prompt(fruits: list) -&gt; None:\n        \\\"\"\"\n        You are a helpful assistant that takes a list of fruit and gives information about their nutrition.\n\n        LIST OF FRUIT:\n        {% for fruit in fruits %}{{ fruit }}\n        {% endfor %}\n        \\\"\"\"\n\n    print(fruit_prompt([\"apple\", \"orange\"]))\n    ```\n\n    Expected Output:\n    ```\n    You are a helpful assistant that takes a list of fruit and gives information about their nutrition.\n\n    LIST OF FRUIT:\n    apple\n    orange\n    ```\n    \"\"\"\n\n    @wraps(func)\n    def wrapper(*args, **kwargs) -&gt; str:\n        docstring = func.__doc__ or \"\"\n        template = Template(docstring, undefined=StrictUndefined)\n\n        # Get function signature and bind arguments\n        sig = signature(func)\n        bound_args = sig.bind(*args, **kwargs)\n        bound_args.apply_defaults()\n\n        # Render the template with bound arguments\n        rendered = template.render(**bound_args.arguments)\n\n        # Strip each line and remove leading/trailing whitespaces\n        stripped_lines = [line.lstrip() for line in rendered.splitlines()]\n        return \"\\n\".join(stripped_lines).strip()\n\n    return wrapper\n</code></pre>"},{"location":"api/core/atoms/prompt/#SilverLingua.core.atoms.prompt.RolePrompt","title":"RolePrompt","text":"<pre><code>RolePrompt(role: str, text: str)\n</code></pre> <p>{{ role }}: {{ text }}</p> Source code in <code>src/SilverLingua/core/atoms/prompt.py</code> <pre><code>@prompt\ndef RolePrompt(role: str, text: str):  # type: ignore\n    \"\"\"{{ role }}: {{ text }}\"\"\"\n</code></pre>"},{"location":"api/core/atoms/role/","title":"Role","text":""},{"location":"api/core/atoms/role/#SilverLingua.core.atoms.role","title":"role","text":"<p>Role-related functionality for SilverLingua.</p> <p>This module provides enums and utilities for handling different types of roles in conversations: - Chat roles (system, human, AI, etc.) - React roles (thought, observation, action, etc.)</p>"},{"location":"api/core/atoms/role/#SilverLingua.core.atoms.role.ChatRole","title":"ChatRole","text":"<p>               Bases: <code>Enum</code></p> <p>Standardized roles for chat messages.</p> Warning <p>Do not instantiate this enum directly. Use <code>create_chat_role()</code> instead.</p>"},{"location":"api/core/atoms/role/#SilverLingua.core.atoms.role.ChatRole.SYSTEM","title":"SYSTEM  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SYSTEM = RoleMember('SYSTEM', 'SYSTEM')\n</code></pre>"},{"location":"api/core/atoms/role/#SilverLingua.core.atoms.role.ChatRole.HUMAN","title":"HUMAN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HUMAN = RoleMember('HUMAN', 'HUMAN')\n</code></pre>"},{"location":"api/core/atoms/role/#SilverLingua.core.atoms.role.ChatRole.AI","title":"AI  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AI = RoleMember('AI', 'AI')\n</code></pre>"},{"location":"api/core/atoms/role/#SilverLingua.core.atoms.role.ChatRole.TOOL_CALL","title":"TOOL_CALL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TOOL_CALL = RoleMember('TOOL_CALL', 'TOOL_CALL')\n</code></pre>"},{"location":"api/core/atoms/role/#SilverLingua.core.atoms.role.ChatRole.TOOL_RESPONSE","title":"TOOL_RESPONSE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TOOL_RESPONSE = RoleMember('TOOL_RESPONSE', 'TOOL_RESPONSE')\n</code></pre>"},{"location":"api/core/atoms/role/#SilverLingua.core.atoms.role.RoleMember","title":"RoleMember","text":"<pre><code>RoleMember(name, value, parent=None)\n</code></pre> <p>Used in ChatRole and ReactRole.</p> Warning <p>Do not instantiate this class directly. See ChatRole and ReactRole for more information.</p> Source code in <code>src/SilverLingua/core/atoms/role/member.py</code> <pre><code>def __init__(self, name, value, parent=None):\n    self.__dict__[\"_name\"] = name\n    self.__dict__[\"_value\"] = value\n    self.__dict__[\"_parent\"] = parent\n</code></pre>"},{"location":"api/core/atoms/role/#SilverLingua.core.atoms.role.RoleMember.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/core/atoms/role/#SilverLingua.core.atoms.role.RoleMember.value","title":"value  <code>property</code>","text":"<pre><code>value: str\n</code></pre>"},{"location":"api/core/atoms/role/#SilverLingua.core.atoms.role.ReactRole","title":"ReactRole","text":"<p>               Bases: <code>Enum</code></p> <p>Standardized roles for ReAct framework to help with chain-of-thought prompting.</p> <p>See: https://www.promptingguide.ai/techniques/react</p> Warning <p>Do not instantiate this enum directly. Use <code>create_react_role()</code> instead.</p>"},{"location":"api/core/atoms/role/#SilverLingua.core.atoms.role.ReactRole.QUESTION","title":"QUESTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>QUESTION = RoleMember('QUESTION', 'QUESTION')\n</code></pre>"},{"location":"api/core/atoms/role/#SilverLingua.core.atoms.role.ReactRole.THOUGHT","title":"THOUGHT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>THOUGHT = RoleMember('THOUGHT', 'THOUGHT')\n</code></pre>"},{"location":"api/core/atoms/role/#SilverLingua.core.atoms.role.ReactRole.ACTION","title":"ACTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTION = RoleMember('ACTION', 'ACTION')\n</code></pre>"},{"location":"api/core/atoms/role/#SilverLingua.core.atoms.role.ReactRole.OBSERVATION","title":"OBSERVATION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OBSERVATION = RoleMember('OBSERVATION', 'OBSERVATION')\n</code></pre>"},{"location":"api/core/atoms/role/#SilverLingua.core.atoms.role.ReactRole.ANSWER","title":"ANSWER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ANSWER = RoleMember('ANSWER', 'ANSWER')\n</code></pre>"},{"location":"api/core/atoms/role/#SilverLingua.core.atoms.role.create_chat_role","title":"create_chat_role","text":"<pre><code>create_chat_role(name: str, SYSTEM: str, HUMAN: str, AI: str, TOOL_CALL: str, TOOL_RESPONSE: str) -&gt; Type[ChatRole]\n</code></pre> <p>Create a new ChatRole enum with only the values of the RoleMembers changed.</p> <p>This will ensure that the parent of each member is ChatRole, which means that the members will be equal to the members of ChatRole.</p> Example <pre><code>OpenAIChatRole = create_chat_role(\n    \"OpenAIChatRole\",\n    SYSTEM=\"system\",\n    HUMAN=\"user\",\n    AI=\"assistant\",\n    TOOL_CALL=\"function_call\",\n    TOOL_RESPONSE=\"function\",\n)\n\nassert OpenAIChatRole.SYSTEM == ChatRole.SYSTEM # True\n</code></pre> Source code in <code>src/SilverLingua/core/atoms/role/chat.py</code> <pre><code>def create_chat_role(\n    name: str, SYSTEM: str, HUMAN: str, AI: str, TOOL_CALL: str, TOOL_RESPONSE: str\n) -&gt; Type[ChatRole]:\n    \"\"\"\n    Create a new ChatRole enum with only the values of the RoleMembers changed.\n\n    This will ensure that the parent of each member is ChatRole, which means\n    that the members will be equal to the members of ChatRole.\n\n    Example:\n        ```python\n        OpenAIChatRole = create_chat_role(\n            \"OpenAIChatRole\",\n            SYSTEM=\"system\",\n            HUMAN=\"user\",\n            AI=\"assistant\",\n            TOOL_CALL=\"function_call\",\n            TOOL_RESPONSE=\"function\",\n        )\n\n        assert OpenAIChatRole.SYSTEM == ChatRole.SYSTEM # True\n        ```\n    \"\"\"\n    return Enum(\n        name,\n        {\n            \"SYSTEM\": RoleMember(\"SYSTEM\", SYSTEM, ChatRole),\n            \"HUMAN\": RoleMember(\"HUMAN\", HUMAN, ChatRole),\n            \"AI\": RoleMember(\"AI\", AI, ChatRole),\n            \"TOOL_CALL\": RoleMember(\"TOOL_CALL\", TOOL_CALL, ChatRole),\n            \"TOOL_RESPONSE\": RoleMember(\"TOOL_RESPONSE\", TOOL_RESPONSE, ChatRole),\n        },\n    )\n</code></pre>"},{"location":"api/core/atoms/role/#SilverLingua.core.atoms.role.create_react_role","title":"create_react_role","text":"<pre><code>create_react_role(name: str, QUESTION: str, THOUGHT: str, ACTION: str, OBSERVATION: str, ANSWER: str) -&gt; Type[ReactRole]\n</code></pre> Source code in <code>src/SilverLingua/core/atoms/role/react.py</code> <pre><code>def create_react_role(\n    name: str,\n    QUESTION: str,\n    THOUGHT: str,\n    ACTION: str,\n    OBSERVATION: str,\n    ANSWER: str,\n) -&gt; Type[ReactRole]:\n    return Enum(\n        name,\n        {\n            \"QUESTION\": RoleMember(\"QUESTION\", QUESTION, ReactRole),\n            \"THOUGHT\": RoleMember(\"THOUGHT\", THOUGHT, ReactRole),\n            \"ACTION\": RoleMember(\"ACTION\", ACTION, ReactRole),\n            \"OBSERVATION\": RoleMember(\"OBSERVATION\", OBSERVATION, ReactRole),\n            \"ANSWER\": RoleMember(\"ANSWER\", ANSWER, ReactRole),\n        },\n    )\n</code></pre>"},{"location":"api/core/atoms/tokenizer/","title":"Tokenizer","text":""},{"location":"api/core/atoms/tokenizer/#SilverLingua.core.atoms.tokenizer","title":"tokenizer","text":""},{"location":"api/core/atoms/tokenizer/#SilverLingua.core.atoms.tokenizer.Tokenizer","title":"Tokenizer","text":"<p>               Bases: <code>BaseModel</code></p> <p>A tokenizer that can encode and decode strings.</p>"},{"location":"api/core/atoms/tokenizer/#SilverLingua.core.atoms.tokenizer.Tokenizer.encode","title":"encode  <code>instance-attribute</code>","text":"<pre><code>encode: Callable[[str], List[int]]\n</code></pre>"},{"location":"api/core/atoms/tokenizer/#SilverLingua.core.atoms.tokenizer.Tokenizer.decode","title":"decode  <code>instance-attribute</code>","text":"<pre><code>decode: Callable[[List[int]], str]\n</code></pre>"},{"location":"api/core/atoms/tool/","title":"Tool","text":""},{"location":"api/core/atoms/tool/#SilverLingua.core.atoms.tool","title":"tool","text":""},{"location":"api/core/atoms/tool/#SilverLingua.core.atoms.tool.Tool","title":"Tool","text":"<pre><code>Tool(function: Callable)\n</code></pre> <p>               Bases: <code>BaseModel</code></p> <p>A wrapper class for functions that allows them to be both directly callable and serializable to JSON for use with an LLM.</p> <p>Attributes:</p> Name Type Description <code>function</code> <code>Callable</code> <p>The function to be wrapped.</p> <code>description</code> <code>FunctionJSONSchema</code> <p>A TypedDict that describes the function according to JSON schema standards.</p> <code>name</code> <code>str</code> <p>The name of the function, extracted from the FunctionJSONSchema.</p> See also <ul> <li><code>Agent</code></li> <li><code>Model</code></li> </ul> Example <pre><code>def my_function(x, y):\n    return x + y\n\n# Create a Tool instance\ntool_instance = Tool(my_function)\n\n# Directly call the wrapped function\nresult = tool_instance(1, 2)  # Output will be 3\n\n# Serialize to JSON\nserialized = str(tool_instance)\n\n####\n# Alternatively, you can use the decorator to turn a function into a Tool.\n####\n\n@tool\ndef my_function(x, y):\n    return x + y\n\n# Now the function itself is already a Tool.\nresult = my_function(1, 2)  # Output will be 3\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Callable</code> <p>The function to be turned into a Tool.</p> required Source code in <code>src/SilverLingua/core/atoms/tool/tool.py</code> <pre><code>def __init__(self, function: Callable):\n    \"\"\"\n    Args:\n        function (Callable): The function to be turned into a Tool.\n    \"\"\"\n    description = generate_function_json(function)\n    name = description.name\n    super().__init__(function=function, description=description, name=name)\n</code></pre>"},{"location":"api/core/atoms/tool/#SilverLingua.core.atoms.tool.Tool.function","title":"function  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>function: Callable = Field(exclude=True)\n</code></pre>"},{"location":"api/core/atoms/tool/#SilverLingua.core.atoms.tool.Tool.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: FunctionJSONSchema = Field(validate_default=True)\n</code></pre>"},{"location":"api/core/atoms/tool/#SilverLingua.core.atoms.tool.Tool.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = Field(validate_default=True)\n</code></pre>"},{"location":"api/core/atoms/tool/#SilverLingua.core.atoms.tool.Tool.use_function_call","title":"use_function_call","text":"<pre><code>use_function_call(function_call: ToolCallFunction)\n</code></pre> <p>Uses a FunctionCall to call the function.</p> Source code in <code>src/SilverLingua/core/atoms/tool/tool.py</code> <pre><code>def use_function_call(self, function_call: ToolCallFunction):\n    \"\"\"\n    Uses a FunctionCall to call the function.\n    \"\"\"\n    arguments_dict = function_call.arguments\n    if arguments_dict == \"\":\n        return json.dumps(self.function())\n\n    try:\n        arguments_dict = json.loads(function_call.arguments)\n    except json.JSONDecodeError:\n        raise ValueError(\n            \"ToolCall.arguments must be a JSON string.\\n\"\n            + f\"function_call.arguments: {function_call.arguments}\\n\"\n            + f\"json.loads result: {arguments_dict}\"\n        ) from None\n\n    return json.dumps(self.function(**arguments_dict))\n</code></pre>"},{"location":"api/core/atoms/tool/#SilverLingua.core.atoms.tool.FunctionJSONSchema","title":"FunctionJSONSchema","text":"<p>               Bases: <code>BaseModel</code></p> <p>A function according to JSON schema standards.</p> <p>This is also passed in to OpenAI ChatCompletion API functions list so the AI understands how to call a function.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the function</p> <code>description</code> <code>str</code> <p>A description of the function</p> <code>parameters</code> <code>Parameters</code> <p>A dictionary of parameters and their types (Optional)</p> <p>Example:</p> <pre><code>{\n    \"name\": \"roll_dice\",\n    \"description\": \"Rolls a number of dice with a given number of sides, optionally\n        with a modifier and/or advantage/disadvantage.\n        Returns `{result: int, rolls: int[]}`\",\n    \"parameters\": {\n        \"type\": \"object\",\n        \"properties\": {\n            \"sides\": {\n              \"description\": \"The number of sides on each die\",\n              \"type\": \"integer\"\n            },\n            \"dice\": {\n              \"description\": \"The number of dice to roll (default 1)\",\n              \"type\": \"integer\"\n            },\n            \"modifier\": {\n              \"description\": \"The modifier to add to the roll total (default 0)\",\n              \"type\": \"integer\"\n            },\n            \"advantage\": {\n              \"description\": \"Whether to roll with advantage (default False)\",\n              \"type\": \"boolean\"\n            },\n            \"disadvantage\": {\n              \"description\": \"Whether to roll with disadvantage (default False)\",\n              \"type\": \"boolean\"\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"api/core/atoms/tool/#SilverLingua.core.atoms.tool.FunctionJSONSchema.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/core/atoms/tool/#SilverLingua.core.atoms.tool.FunctionJSONSchema.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str\n</code></pre>"},{"location":"api/core/atoms/tool/#SilverLingua.core.atoms.tool.FunctionJSONSchema.parameters","title":"parameters  <code>instance-attribute</code>","text":"<pre><code>parameters: Parameters\n</code></pre>"},{"location":"api/core/atoms/tool/#SilverLingua.core.atoms.tool.ToolCall","title":"ToolCall","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/core/atoms/tool/#SilverLingua.core.atoms.tool.ToolCall.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(extra='allow', ignored_types=(type(None)))\n</code></pre>"},{"location":"api/core/atoms/tool/#SilverLingua.core.atoms.tool.ToolCall.function","title":"function  <code>instance-attribute</code>","text":"<pre><code>function: ToolCallFunction\n</code></pre>"},{"location":"api/core/atoms/tool/#SilverLingua.core.atoms.tool.ToolCall.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = Field(default_factory=lambda: str(uuid4()))\n</code></pre>"},{"location":"api/core/atoms/tool/#SilverLingua.core.atoms.tool.ToolCall.index","title":"index  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>index: Optional[int] = None\n</code></pre>"},{"location":"api/core/atoms/tool/#SilverLingua.core.atoms.tool.ToolCall.string_if_none","title":"string_if_none","text":"<pre><code>string_if_none(v)\n</code></pre> Source code in <code>src/SilverLingua/core/atoms/tool/util.py</code> <pre><code>@field_validator(\"id\", mode=\"before\")\ndef string_if_none(cls, v):\n    return v if v is not None else str(uuid4())\n</code></pre>"},{"location":"api/core/atoms/tool/#SilverLingua.core.atoms.tool.ToolCall.concat","title":"concat","text":"<pre><code>concat(other: ToolCall) -&gt; ToolCall\n</code></pre> <p>Concatenates two tool calls and returns the result.</p> <p>If the IDs are different, prioritize the ID of 'self'. For 'function', merge the 'name' and 'arguments' fields.</p> <p>We will prefer the <code>id</code> of self over other for 2 reasons: 1. We assume that self is the older of the two 2. The newer may be stream chunked, in which case the <code>id</code> of <code>other</code> may have been <code>None</code> and generated using UUID, but the older ID likely was generated by an API and thus this newer ID is not the true ID.</p> Source code in <code>src/SilverLingua/core/atoms/tool/util.py</code> <pre><code>def concat(self, other: \"ToolCall\") -&gt; \"ToolCall\":\n    \"\"\"\n    Concatenates two tool calls and returns the result.\n\n    If the IDs are different, prioritize the ID of 'self'.\n    For 'function', merge the 'name' and 'arguments' fields.\n\n    We will prefer the `id` of self over other for 2 reasons:\n    1. We assume that self is the older of the two\n    2. The newer may be stream chunked, in which case\n    the `id` of `other` may have been `None` and generated\n    using UUID, but the older ID likely was generated\n    by an API and thus this newer ID is not the true ID.\n    \"\"\"\n    merged_function = {\n        \"name\": self.function.name or other.function.name,\n        \"arguments\": (self.function.arguments or \"\")\n        + (other.function.arguments or \"\"),\n    }\n    merged_function = ToolCallFunction(**merged_function)\n\n    self_extra = self.__pydantic_extra__\n    other_extra = other.__pydantic_extra__\n\n    index = self.index if self.index is not None else other.index\n\n    # Compare the two extra fields\n    if self_extra != other_extra:\n        if not self_extra or not other_extra:\n            return ToolCall(\n                id=(self.id) or other.id,\n                function=merged_function,\n                index=index,\n                **(self_extra or {}),\n                **(other_extra or {}),\n            )\n        # If they are different, merge them\n        merged_extra = {}\n        for key in set(self_extra.keys()) | set(other_extra.keys()):\n            if key in self_extra and key in other_extra:\n                # If one is None, use the other\n                # Else, concatenate them\n                if self_extra[key] == other_extra[key]:\n                    merged_extra[key] = self_extra[key]\n                else:\n                    if self_extra[key] is None or other_extra[key] is None:\n                        merged_extra[key] = self_extra[key] or other_extra[key]\n                    else:\n                        merged_extra[key] = self_extra[key] + other_extra[key]\n            elif key in self_extra:\n                merged_extra[key] = self_extra[key]\n            elif key in other_extra:\n                merged_extra[key] = other_extra[key]\n        #\n        return ToolCall(\n            id=self.id or other.id,\n            function=merged_function,\n            index=index,\n            **merged_extra,\n        )\n\n    return ToolCall(\n        id=self.id or other.id,\n        function=merged_function,\n        index=index,\n        **(self_extra or {}),\n    )\n</code></pre>"},{"location":"api/core/atoms/tool/#SilverLingua.core.atoms.tool.ToolCallFunction","title":"ToolCallFunction","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/core/atoms/tool/#SilverLingua.core.atoms.tool.ToolCallFunction.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = Field(default='')\n</code></pre>"},{"location":"api/core/atoms/tool/#SilverLingua.core.atoms.tool.ToolCallFunction.arguments","title":"arguments  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>arguments: str = Field(default='')\n</code></pre>"},{"location":"api/core/atoms/tool/#SilverLingua.core.atoms.tool.ToolCallFunction.string_if_none","title":"string_if_none","text":"<pre><code>string_if_none(v)\n</code></pre> Source code in <code>src/SilverLingua/core/atoms/tool/util.py</code> <pre><code>@field_validator(\"*\", mode=\"before\")\ndef string_if_none(cls, v):\n    return v if v is not None else \"\"\n</code></pre>"},{"location":"api/core/atoms/tool/#SilverLingua.core.atoms.tool.ToolCallResponse","title":"ToolCallResponse","text":"<p>               Bases: <code>BaseModel</code></p> <p>The response property of a tool call.</p>"},{"location":"api/core/atoms/tool/#SilverLingua.core.atoms.tool.ToolCallResponse.tool_call_id","title":"tool_call_id  <code>instance-attribute</code>","text":"<pre><code>tool_call_id: str\n</code></pre>"},{"location":"api/core/atoms/tool/#SilverLingua.core.atoms.tool.ToolCallResponse.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/core/atoms/tool/#SilverLingua.core.atoms.tool.ToolCallResponse.content","title":"content  <code>instance-attribute</code>","text":"<pre><code>content: str\n</code></pre>"},{"location":"api/core/atoms/tool/#SilverLingua.core.atoms.tool.ToolCallResponse.from_tool_call","title":"from_tool_call  <code>classmethod</code>","text":"<pre><code>from_tool_call(tool_call: ToolCall, response: str) -&gt; ToolCallResponse\n</code></pre> Source code in <code>src/SilverLingua/core/atoms/tool/util.py</code> <pre><code>@classmethod\ndef from_tool_call(cls, tool_call: \"ToolCall\", response: str) -&gt; \"ToolCallResponse\":\n    return cls(\n        tool_call_id=tool_call.id,\n        name=tool_call.function.name,\n        content=response,\n    )\n</code></pre>"},{"location":"api/core/atoms/tool/#SilverLingua.core.atoms.tool.ToolCalls","title":"ToolCalls","text":"<p>               Bases: <code>BaseModel</code></p> <p>A list of tool calls.</p>"},{"location":"api/core/atoms/tool/#SilverLingua.core.atoms.tool.ToolCalls.list","title":"list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>list: List[ToolCall] = Field(default_factory=list, frozen=True)\n</code></pre>"},{"location":"api/core/atoms/tool/#SilverLingua.core.atoms.tool.ToolCalls.concat","title":"concat","text":"<pre><code>concat(other: ToolCalls) -&gt; ToolCalls\n</code></pre> <p>Concatenates two tool calls lists and returns the result.</p> Source code in <code>src/SilverLingua/core/atoms/tool/util.py</code> <pre><code>def concat(self, other: \"ToolCalls\") -&gt; \"ToolCalls\":\n    \"\"\"\n    Concatenates two tool calls lists and returns the result.\n    \"\"\"\n    new: List[ToolCall] = self.list.copy()\n    for tool_call in other.list:\n        found = False\n        # Find the tool call with the same ID\n        for i, self_tool_call in enumerate(new):\n            if (\n                self_tool_call.id == tool_call.id\n                or self_tool_call.index == tool_call.index\n            ):\n                new[i] = self_tool_call.concat(tool_call)\n                found = True\n        if not found:\n            new.append(tool_call)\n    return ToolCalls(list=new)\n</code></pre>"},{"location":"api/core/molecules/","title":"index","text":""},{"location":"api/core/molecules/#SilverLingua.core.molecules","title":"molecules","text":"<p>Molecules represent self-contained conceptual units that combine atoms to create more complex  but focused components. They focus on \"what something is\" rather than \"what it does.\"</p> <p>See Design Principles - Molecules for more details.</p>"},{"location":"api/core/molecules/#SilverLingua.core.molecules.Link","title":"Link","text":"<p>               Bases: <code>Memory</code></p> <p>A memory that can have a parent and children Links, forming a hierarchical structure of interconnected memories.</p> <p>The content can be either a <code>Notion</code> or a <code>Memory</code>. (You can still use the content as a string via <code>str(link.content)</code>.)</p>"},{"location":"api/core/molecules/#SilverLingua.core.molecules.Link.content","title":"content  <code>instance-attribute</code>","text":"<pre><code>content: Union[Notion, Memory]\n</code></pre>"},{"location":"api/core/molecules/#SilverLingua.core.molecules.Link.parent","title":"parent  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parent: Optional[Link] = None\n</code></pre>"},{"location":"api/core/molecules/#SilverLingua.core.molecules.Link.children","title":"children  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>children: List[Link] = Field(default_factory=list)\n</code></pre>"},{"location":"api/core/molecules/#SilverLingua.core.molecules.Link.path","title":"path  <code>property</code>","text":"<pre><code>path: List[Link]\n</code></pre> <p>Returns the path from the root to this Link.</p>"},{"location":"api/core/molecules/#SilverLingua.core.molecules.Link.root","title":"root  <code>property</code>","text":"<pre><code>root: Link\n</code></pre> <p>Returns the root Link of this Link.</p>"},{"location":"api/core/molecules/#SilverLingua.core.molecules.Link.depth","title":"depth  <code>property</code>","text":"<pre><code>depth: int\n</code></pre> <p>Returns 1 based depth of this Link.</p>"},{"location":"api/core/molecules/#SilverLingua.core.molecules.Link.is_root","title":"is_root  <code>property</code>","text":"<pre><code>is_root: bool\n</code></pre> <p>Returns whether this Link is a root Link.</p>"},{"location":"api/core/molecules/#SilverLingua.core.molecules.Link.is_leaf","title":"is_leaf  <code>property</code>","text":"<pre><code>is_leaf: bool\n</code></pre> <p>Returns whether this Link is a leaf Link.</p>"},{"location":"api/core/molecules/#SilverLingua.core.molecules.Link.is_branch","title":"is_branch  <code>property</code>","text":"<pre><code>is_branch: bool\n</code></pre> <p>Returns whether this Link is a branch Link.</p>"},{"location":"api/core/molecules/#SilverLingua.core.molecules.Link.path_string","title":"path_string  <code>property</code>","text":"<pre><code>path_string: str\n</code></pre> <p>Returns the path from the root to this Link as a string.</p> <p>Example: \"root&gt;child&gt;grandchild\"</p>"},{"location":"api/core/molecules/#SilverLingua.core.molecules.Link.add_child","title":"add_child","text":"<pre><code>add_child(child: Link) -&gt; None\n</code></pre> Source code in <code>src/SilverLingua/core/molecules/link.py</code> <pre><code>def add_child(self, child: \"Link\") -&gt; None:\n    self.children.append(child)\n    child.parent = self\n</code></pre>"},{"location":"api/core/molecules/#SilverLingua.core.molecules.Link.remove_child","title":"remove_child","text":"<pre><code>remove_child(child: Link) -&gt; None\n</code></pre> Source code in <code>src/SilverLingua/core/molecules/link.py</code> <pre><code>def remove_child(self, child: \"Link\") -&gt; None:\n    self.children.remove(child)\n    child.parent = None\n</code></pre>"},{"location":"api/core/molecules/#SilverLingua.core.molecules.Notion","title":"Notion","text":"<pre><code>Notion(content: str, role: Union[ChatRole, ReactRole, str], persistent: bool = False)\n</code></pre> <p>               Bases: <code>Memory</code></p> <p>A memory that stores the role associated with its content. The role is usually a <code>ChatRole</code> or a <code>ReactRole</code>. (See <code>atoms/roles</code>)</p> <p>Attributes:</p> Name Type Description <code>role</code> <code>str</code> <p>The role of the notion.</p> <code>content</code> <code>str</code> <p>The content of the memory.</p> <code>persistent</code> <code>bool</code> <p>Whether the notion should be stored in long-term memory.</p> Source code in <code>src/SilverLingua/core/molecules/notion.py</code> <pre><code>def __init__(\n    self,\n    content: str,\n    role: Union[ChatRole, ReactRole, str],\n    persistent: bool = False,\n):\n    super().__init__(content=content, role=role, persistent=persistent)\n</code></pre>"},{"location":"api/core/molecules/#SilverLingua.core.molecules.Notion.content","title":"content  <code>instance-attribute</code>","text":"<pre><code>content: str\n</code></pre>"},{"location":"api/core/molecules/#SilverLingua.core.molecules.Notion.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(from_attributes=True)\n</code></pre>"},{"location":"api/core/molecules/#SilverLingua.core.molecules.Notion.role","title":"role  <code>instance-attribute</code>","text":"<pre><code>role: str\n</code></pre>"},{"location":"api/core/molecules/#SilverLingua.core.molecules.Notion.persistent","title":"persistent  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>persistent: bool = False\n</code></pre>"},{"location":"api/core/molecules/#SilverLingua.core.molecules.Notion.chat_role","title":"chat_role  <code>property</code>","text":"<pre><code>chat_role: ChatRole\n</code></pre> <p>Gets the chat based role Enum (e.g. Role.SYSTEM, Role.HUMAN, etc.)</p> <p>(See <code>config</code>)</p>"},{"location":"api/core/molecules/#SilverLingua.core.molecules.Notion.react_role","title":"react_role  <code>property</code>","text":"<pre><code>react_role: ReactRole\n</code></pre> <p>Gets the react based role Enum (e.g. Role.THOUGHT, Role.OBSERVATION, etc.)</p> <p>(See <code>config</code>)</p>"},{"location":"api/core/molecules/#SilverLingua.core.molecules.Notion.validate_role","title":"validate_role  <code>classmethod</code>","text":"<pre><code>validate_role(v: Union[ChatRole, ReactRole, str])\n</code></pre> Source code in <code>src/SilverLingua/core/molecules/notion.py</code> <pre><code>@field_validator(\"role\", mode=\"before\")\n@classmethod\ndef validate_role(cls, v: Union[ChatRole, ReactRole, str]):\n    if isinstance(v, (ChatRole, ReactRole)):\n        return v.value.value\n    elif isinstance(v, str):\n        return v\n    raise ValueError(f\"Expected a ChatRole, ReactRole, or a string, got {type(v)}\")\n</code></pre>"},{"location":"api/core/molecules/link/","title":"Link","text":""},{"location":"api/core/molecules/link/#SilverLingua.core.molecules.link","title":"link","text":""},{"location":"api/core/molecules/link/#SilverLingua.core.molecules.link.Link","title":"Link","text":"<p>               Bases: <code>Memory</code></p> <p>A memory that can have a parent and children Links, forming a hierarchical structure of interconnected memories.</p> <p>The content can be either a <code>Notion</code> or a <code>Memory</code>. (You can still use the content as a string via <code>str(link.content)</code>.)</p>"},{"location":"api/core/molecules/link/#SilverLingua.core.molecules.link.Link.content","title":"content  <code>instance-attribute</code>","text":"<pre><code>content: Union[Notion, Memory]\n</code></pre>"},{"location":"api/core/molecules/link/#SilverLingua.core.molecules.link.Link.parent","title":"parent  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parent: Optional[Link] = None\n</code></pre>"},{"location":"api/core/molecules/link/#SilverLingua.core.molecules.link.Link.children","title":"children  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>children: List[Link] = Field(default_factory=list)\n</code></pre>"},{"location":"api/core/molecules/link/#SilverLingua.core.molecules.link.Link.path","title":"path  <code>property</code>","text":"<pre><code>path: List[Link]\n</code></pre> <p>Returns the path from the root to this Link.</p>"},{"location":"api/core/molecules/link/#SilverLingua.core.molecules.link.Link.root","title":"root  <code>property</code>","text":"<pre><code>root: Link\n</code></pre> <p>Returns the root Link of this Link.</p>"},{"location":"api/core/molecules/link/#SilverLingua.core.molecules.link.Link.depth","title":"depth  <code>property</code>","text":"<pre><code>depth: int\n</code></pre> <p>Returns 1 based depth of this Link.</p>"},{"location":"api/core/molecules/link/#SilverLingua.core.molecules.link.Link.is_root","title":"is_root  <code>property</code>","text":"<pre><code>is_root: bool\n</code></pre> <p>Returns whether this Link is a root Link.</p>"},{"location":"api/core/molecules/link/#SilverLingua.core.molecules.link.Link.is_leaf","title":"is_leaf  <code>property</code>","text":"<pre><code>is_leaf: bool\n</code></pre> <p>Returns whether this Link is a leaf Link.</p>"},{"location":"api/core/molecules/link/#SilverLingua.core.molecules.link.Link.is_branch","title":"is_branch  <code>property</code>","text":"<pre><code>is_branch: bool\n</code></pre> <p>Returns whether this Link is a branch Link.</p>"},{"location":"api/core/molecules/link/#SilverLingua.core.molecules.link.Link.path_string","title":"path_string  <code>property</code>","text":"<pre><code>path_string: str\n</code></pre> <p>Returns the path from the root to this Link as a string.</p> <p>Example: \"root&gt;child&gt;grandchild\"</p>"},{"location":"api/core/molecules/link/#SilverLingua.core.molecules.link.Link.add_child","title":"add_child","text":"<pre><code>add_child(child: Link) -&gt; None\n</code></pre> Source code in <code>src/SilverLingua/core/molecules/link.py</code> <pre><code>def add_child(self, child: \"Link\") -&gt; None:\n    self.children.append(child)\n    child.parent = self\n</code></pre>"},{"location":"api/core/molecules/link/#SilverLingua.core.molecules.link.Link.remove_child","title":"remove_child","text":"<pre><code>remove_child(child: Link) -&gt; None\n</code></pre> Source code in <code>src/SilverLingua/core/molecules/link.py</code> <pre><code>def remove_child(self, child: \"Link\") -&gt; None:\n    self.children.remove(child)\n    child.parent = None\n</code></pre>"},{"location":"api/core/molecules/notion/","title":"Notion","text":""},{"location":"api/core/molecules/notion/#SilverLingua.core.molecules.notion","title":"notion","text":""},{"location":"api/core/molecules/notion/#SilverLingua.core.molecules.notion.Notion","title":"Notion","text":"<pre><code>Notion(content: str, role: Union[ChatRole, ReactRole, str], persistent: bool = False)\n</code></pre> <p>               Bases: <code>Memory</code></p> <p>A memory that stores the role associated with its content. The role is usually a <code>ChatRole</code> or a <code>ReactRole</code>. (See <code>atoms/roles</code>)</p> <p>Attributes:</p> Name Type Description <code>role</code> <code>str</code> <p>The role of the notion.</p> <code>content</code> <code>str</code> <p>The content of the memory.</p> <code>persistent</code> <code>bool</code> <p>Whether the notion should be stored in long-term memory.</p> Source code in <code>src/SilverLingua/core/molecules/notion.py</code> <pre><code>def __init__(\n    self,\n    content: str,\n    role: Union[ChatRole, ReactRole, str],\n    persistent: bool = False,\n):\n    super().__init__(content=content, role=role, persistent=persistent)\n</code></pre>"},{"location":"api/core/molecules/notion/#SilverLingua.core.molecules.notion.Notion.content","title":"content  <code>instance-attribute</code>","text":"<pre><code>content: str\n</code></pre>"},{"location":"api/core/molecules/notion/#SilverLingua.core.molecules.notion.Notion.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(from_attributes=True)\n</code></pre>"},{"location":"api/core/molecules/notion/#SilverLingua.core.molecules.notion.Notion.role","title":"role  <code>instance-attribute</code>","text":"<pre><code>role: str\n</code></pre>"},{"location":"api/core/molecules/notion/#SilverLingua.core.molecules.notion.Notion.persistent","title":"persistent  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>persistent: bool = False\n</code></pre>"},{"location":"api/core/molecules/notion/#SilverLingua.core.molecules.notion.Notion.chat_role","title":"chat_role  <code>property</code>","text":"<pre><code>chat_role: ChatRole\n</code></pre> <p>Gets the chat based role Enum (e.g. Role.SYSTEM, Role.HUMAN, etc.)</p> <p>(See <code>config</code>)</p>"},{"location":"api/core/molecules/notion/#SilverLingua.core.molecules.notion.Notion.react_role","title":"react_role  <code>property</code>","text":"<pre><code>react_role: ReactRole\n</code></pre> <p>Gets the react based role Enum (e.g. Role.THOUGHT, Role.OBSERVATION, etc.)</p> <p>(See <code>config</code>)</p>"},{"location":"api/core/molecules/notion/#SilverLingua.core.molecules.notion.Notion.validate_role","title":"validate_role  <code>classmethod</code>","text":"<pre><code>validate_role(v: Union[ChatRole, ReactRole, str])\n</code></pre> Source code in <code>src/SilverLingua/core/molecules/notion.py</code> <pre><code>@field_validator(\"role\", mode=\"before\")\n@classmethod\ndef validate_role(cls, v: Union[ChatRole, ReactRole, str]):\n    if isinstance(v, (ChatRole, ReactRole)):\n        return v.value.value\n    elif isinstance(v, str):\n        return v\n    raise ValueError(f\"Expected a ChatRole, ReactRole, or a string, got {type(v)}\")\n</code></pre>"},{"location":"api/core/organisms/","title":"index","text":""},{"location":"api/core/organisms/#SilverLingua.core.organisms","title":"organisms","text":"<p>Organisms are complex components that coordinate multiple molecules and atoms to perform  sophisticated tasks. They focus on \"what something does\" and how it orchestrates behavior.</p> <p>See Design Principles - Organisms for more details.</p>"},{"location":"api/core/organisms/#SilverLingua.core.organisms.Idearium","title":"Idearium","text":"<pre><code>Idearium(tokenizer: Tokenizer, max_tokens: int, notions: List[Notion] = None, **kwargs)\n</code></pre> <p>               Bases: <code>BaseModel</code></p> <p>A collection of <code>Notions</code> that is automatically trimmed to fit within a maximum number of tokens.</p> Source code in <code>src/SilverLingua/core/organisms/idearium.py</code> <pre><code>def __init__(\n    self,\n    tokenizer: Tokenizer,\n    max_tokens: int,\n    notions: List[Notion] = None,\n    **kwargs,\n):\n    # Initialize with empty notions if None\n    notions = notions or []\n\n    # Initialize tokenized_notions\n    tokenized_notions = [tokenizer.encode(notion.content) for notion in notions]\n\n    # Call parent init with all values\n    super().__init__(\n        tokenizer=tokenizer,\n        max_tokens=max_tokens,\n        notions=notions,\n        tokenized_notions=tokenized_notions,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/core/organisms/#SilverLingua.core.organisms.Idearium.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(frozen=True)\n</code></pre>"},{"location":"api/core/organisms/#SilverLingua.core.organisms.Idearium.tokenizer","title":"tokenizer  <code>instance-attribute</code>","text":"<pre><code>tokenizer: Tokenizer\n</code></pre>"},{"location":"api/core/organisms/#SilverLingua.core.organisms.Idearium.max_tokens","title":"max_tokens  <code>instance-attribute</code>","text":"<pre><code>max_tokens: int\n</code></pre>"},{"location":"api/core/organisms/#SilverLingua.core.organisms.Idearium.notions","title":"notions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>notions: List[Notion] = Field(default_factory=list)\n</code></pre>"},{"location":"api/core/organisms/#SilverLingua.core.organisms.Idearium.tokenized_notions","title":"tokenized_notions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tokenized_notions: List[List[int]] = Field(default_factory=list)\n</code></pre>"},{"location":"api/core/organisms/#SilverLingua.core.organisms.Idearium.persistent_indices","title":"persistent_indices  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>persistent_indices: set = Field(default_factory=set)\n</code></pre>"},{"location":"api/core/organisms/#SilverLingua.core.organisms.Idearium.total_tokens","title":"total_tokens  <code>property</code>","text":"<pre><code>total_tokens: int\n</code></pre> <p>The total number of tokens in the Idearium.</p>"},{"location":"api/core/organisms/#SilverLingua.core.organisms.Idearium._non_persistent_indices","title":"_non_persistent_indices  <code>property</code>","text":"<pre><code>_non_persistent_indices: set\n</code></pre> <p>The indices of non-persistent notions.</p>"},{"location":"api/core/organisms/#SilverLingua.core.organisms.Idearium.validate_notions","title":"validate_notions","text":"<pre><code>validate_notions(values)\n</code></pre> Source code in <code>src/SilverLingua/core/organisms/idearium.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_notions(cls, values):\n    notions = values.notions\n    for notion in notions:\n        cls.validate_notion(notion, values.max_tokens, values.tokenizer)\n    return values\n</code></pre>"},{"location":"api/core/organisms/#SilverLingua.core.organisms.Idearium.validate_notion","title":"validate_notion  <code>classmethod</code>","text":"<pre><code>validate_notion(notion: Notion, max_tokens: int, tokenizer: Tokenizer)\n</code></pre> Source code in <code>src/SilverLingua/core/organisms/idearium.py</code> <pre><code>@classmethod\ndef validate_notion(cls, notion: Notion, max_tokens: int, tokenizer: Tokenizer):\n    if len(notion.content) == 0:\n        raise ValueError(\"Notion content cannot be empty.\")\n\n    tokenized_notion = tokenizer.encode(notion.content)\n    if len(tokenized_notion) &gt; max_tokens:\n        raise ValueError(\"Notion exceeds maximum token length\")\n\n    return tokenized_notion\n</code></pre>"},{"location":"api/core/organisms/#SilverLingua.core.organisms.Idearium.index","title":"index","text":"<pre><code>index(notion: Notion) -&gt; int\n</code></pre> <p>Returns the index of the first occurrence of the given notion.</p> Source code in <code>src/SilverLingua/core/organisms/idearium.py</code> <pre><code>def index(self, notion: Notion) -&gt; int:\n    \"\"\"Returns the index of the first occurrence of the given notion.\"\"\"\n    return self.notions.index(notion)\n</code></pre>"},{"location":"api/core/organisms/#SilverLingua.core.organisms.Idearium.append","title":"append","text":"<pre><code>append(notion: Notion)\n</code></pre> <p>Appends the given notion to the end of the Idearium.</p> Source code in <code>src/SilverLingua/core/organisms/idearium.py</code> <pre><code>def append(self, notion: Notion):\n    \"\"\"Appends the given notion to the end of the Idearium.\"\"\"\n    logger.debug(f\"Appending notion: {notion.content!r}\")\n    tokenized_notion = self.tokenizer.encode(notion.content)\n\n    if self.notions:\n        logger.debug(f\"Current last notion: {self.notions[-1].content!r}\")\n\n    if (\n        self.notions\n        and self.notions[-1].role == notion.role\n        and self.notions[-1].persistent == notion.persistent\n    ):\n        combined_content = self.notions[-1].content + notion.content\n        combined_notion = Notion(\n            content=combined_content,\n            role=notion.role,\n            persistent=notion.persistent,\n        )\n        self.replace(len(self.notions) - 1, combined_notion)\n        logger.debug(\n            f\"After replace, about to return combined content: {combined_content!r}\"\n        )\n        return\n\n    logger.debug(f\"Hitting append path. Appending new notion: {notion.content!r}\")\n    self.notions.append(notion)\n    self.tokenized_notions.append(tokenized_notion)\n\n    if notion.persistent:\n        # Modify the set in place instead of reassigning\n        self.persistent_indices.add(len(self.notions) - 1)\n\n    self._trim()\n</code></pre>"},{"location":"api/core/organisms/#SilverLingua.core.organisms.Idearium.extend","title":"extend","text":"<pre><code>extend(notions: Union[List[Notion], Idearium])\n</code></pre> <p>Extends the Idearium with the given list of notions.</p> Source code in <code>src/SilverLingua/core/organisms/idearium.py</code> <pre><code>def extend(self, notions: Union[List[Notion], \"Idearium\"]):\n    \"\"\"Extends the Idearium with the given list of notions.\"\"\"\n    if isinstance(notions, Idearium):\n        notions = notions.notions\n\n    for notion in notions:\n        self.append(notion)\n</code></pre>"},{"location":"api/core/organisms/#SilverLingua.core.organisms.Idearium.insert","title":"insert","text":"<pre><code>insert(index: int, notion: Notion)\n</code></pre> <p>Inserts the given notion at the given index.</p> Source code in <code>src/SilverLingua/core/organisms/idearium.py</code> <pre><code>def insert(self, index: int, notion: Notion):\n    \"\"\"Inserts the given notion at the given index.\"\"\"\n    tokenized_notion = self.tokenizer.encode(notion.content)\n\n    self.notions.insert(index, notion)\n    self.tokenized_notions.insert(index, tokenized_notion)\n\n    # Update persistent_indices in place\n    new_indices = {i + 1 if i &gt;= index else i for i in self.persistent_indices}\n    self.persistent_indices.clear()\n    self.persistent_indices.update(new_indices)\n    if notion.persistent:\n        self.persistent_indices.add(index)\n\n    self._trim()\n</code></pre>"},{"location":"api/core/organisms/#SilverLingua.core.organisms.Idearium.remove","title":"remove","text":"<pre><code>remove(notion: Notion)\n</code></pre> <p>Removes the first occurrence of the given notion.</p> Source code in <code>src/SilverLingua/core/organisms/idearium.py</code> <pre><code>def remove(self, notion: Notion):\n    \"\"\"Removes the first occurrence of the given notion.\"\"\"\n    index = self.index(notion)\n    self.pop(index)\n</code></pre>"},{"location":"api/core/organisms/#SilverLingua.core.organisms.Idearium.pop","title":"pop","text":"<pre><code>pop(index: int) -&gt; Notion\n</code></pre> <p>Removes and returns the notion at the given index.</p> Source code in <code>src/SilverLingua/core/organisms/idearium.py</code> <pre><code>def pop(self, index: int) -&gt; Notion:\n    \"\"\"Removes and returns the notion at the given index.\"\"\"\n    ret = self.notions.pop(index)\n    self.tokenized_notions.pop(index)\n\n    # Update persistent_indices\n    # Modify the set in place instead of reassigning\n    self.persistent_indices.discard(index)\n    new_indices = {i - 1 if i &gt; index else i for i in self.persistent_indices}\n    self.persistent_indices.clear()\n    self.persistent_indices.update(new_indices)\n\n    return ret\n</code></pre>"},{"location":"api/core/organisms/#SilverLingua.core.organisms.Idearium.replace","title":"replace","text":"<pre><code>replace(index: int, notion: Notion)\n</code></pre> <p>Replaces the notion at the given index with the given notion.</p> Source code in <code>src/SilverLingua/core/organisms/idearium.py</code> <pre><code>def replace(self, index: int, notion: Notion):\n    \"\"\"Replaces the notion at the given index with the given notion.\"\"\"\n    self.notions[index] = notion\n    self.tokenized_notions[index] = self.tokenizer.encode(notion.content)\n\n    # Update persistent_indices based on the replaced notion\n    if notion.persistent:\n        self.persistent_indices.add(index)\n    else:\n        self.persistent_indices.discard(index)\n\n    self._trim()\n</code></pre>"},{"location":"api/core/organisms/#SilverLingua.core.organisms.Idearium.copy","title":"copy","text":"<pre><code>copy() -&gt; Idearium\n</code></pre> <p>Returns a copy of the Idearium.</p> Source code in <code>src/SilverLingua/core/organisms/idearium.py</code> <pre><code>def copy(self) -&gt; \"Idearium\":\n    \"\"\"Returns a copy of the Idearium.\"\"\"\n    return Idearium(\n        tokenizer=self.tokenizer,\n        max_tokens=self.max_tokens,\n        notions=self.notions.copy(),\n        tokenized_notions=self.tokenized_notions.copy(),\n        persistent_indices=self.persistent_indices.copy(),\n    )\n</code></pre>"},{"location":"api/core/organisms/#SilverLingua.core.organisms.Idearium._trim","title":"_trim","text":"<pre><code>_trim()\n</code></pre> <p>Trims the Idearium to fit within the maximum number of tokens, called after every modification.</p> <p>This is the primary point of extension for Idearium subclasses, as it allows for custom trimming behavior.</p> Source code in <code>src/SilverLingua/core/organisms/idearium.py</code> <pre><code>def _trim(self):\n    \"\"\"\n    Trims the Idearium to fit within the maximum number of tokens, called\n    after every modification.\n\n    This is the primary point of extension for Idearium subclasses, as it\n    allows for custom trimming behavior.\n    \"\"\"\n    while self.total_tokens &gt; self.max_tokens:\n        non_persistent_indices = self._non_persistent_indices\n\n        # Check if there's only one non-persistent user message\n        if len(non_persistent_indices) == 1:\n            single_index = next(iter(non_persistent_indices))\n            tokenized_notion = self.tokenized_notions[single_index]\n\n            # Trim the only non-persistent notion to fit within the token limit\n            tokenized_notion = tokenized_notion[\n                : self.max_tokens - (self.total_tokens - len(tokenized_notion))\n            ]\n            trimmed_content = self.tokenizer.decode(tokenized_notion)\n            trimmed_notion = Notion(\n                content=trimmed_content,\n                role=self.notions[single_index].role,\n                persistent=self.notions[single_index].persistent,\n            )\n            self.replace(single_index, trimmed_notion)\n            return\n\n        # Attempt to remove the first non-persistent notion\n        for i in non_persistent_indices:\n            self.pop(i)\n            break\n        else:\n            # If all notions are persistent and\n            # the max token length is still exceeded\n            raise ValueError(\n                \"Persistent notions exceed max_tokens.\"\n                + \" Reduce the content or increase max_tokens.\"\n            )\n</code></pre>"},{"location":"api/core/organisms/idearium/","title":"Idearium","text":""},{"location":"api/core/organisms/idearium/#SilverLingua.core.organisms.idearium","title":"idearium","text":""},{"location":"api/core/organisms/idearium/#SilverLingua.core.organisms.idearium.Idearium","title":"Idearium","text":"<pre><code>Idearium(tokenizer: Tokenizer, max_tokens: int, notions: List[Notion] = None, **kwargs)\n</code></pre> <p>               Bases: <code>BaseModel</code></p> <p>A collection of <code>Notions</code> that is automatically trimmed to fit within a maximum number of tokens.</p> Source code in <code>src/SilverLingua/core/organisms/idearium.py</code> <pre><code>def __init__(\n    self,\n    tokenizer: Tokenizer,\n    max_tokens: int,\n    notions: List[Notion] = None,\n    **kwargs,\n):\n    # Initialize with empty notions if None\n    notions = notions or []\n\n    # Initialize tokenized_notions\n    tokenized_notions = [tokenizer.encode(notion.content) for notion in notions]\n\n    # Call parent init with all values\n    super().__init__(\n        tokenizer=tokenizer,\n        max_tokens=max_tokens,\n        notions=notions,\n        tokenized_notions=tokenized_notions,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/core/organisms/idearium/#SilverLingua.core.organisms.idearium.Idearium.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(frozen=True)\n</code></pre>"},{"location":"api/core/organisms/idearium/#SilverLingua.core.organisms.idearium.Idearium.tokenizer","title":"tokenizer  <code>instance-attribute</code>","text":"<pre><code>tokenizer: Tokenizer\n</code></pre>"},{"location":"api/core/organisms/idearium/#SilverLingua.core.organisms.idearium.Idearium.max_tokens","title":"max_tokens  <code>instance-attribute</code>","text":"<pre><code>max_tokens: int\n</code></pre>"},{"location":"api/core/organisms/idearium/#SilverLingua.core.organisms.idearium.Idearium.notions","title":"notions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>notions: List[Notion] = Field(default_factory=list)\n</code></pre>"},{"location":"api/core/organisms/idearium/#SilverLingua.core.organisms.idearium.Idearium.tokenized_notions","title":"tokenized_notions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tokenized_notions: List[List[int]] = Field(default_factory=list)\n</code></pre>"},{"location":"api/core/organisms/idearium/#SilverLingua.core.organisms.idearium.Idearium.persistent_indices","title":"persistent_indices  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>persistent_indices: set = Field(default_factory=set)\n</code></pre>"},{"location":"api/core/organisms/idearium/#SilverLingua.core.organisms.idearium.Idearium.total_tokens","title":"total_tokens  <code>property</code>","text":"<pre><code>total_tokens: int\n</code></pre> <p>The total number of tokens in the Idearium.</p>"},{"location":"api/core/organisms/idearium/#SilverLingua.core.organisms.idearium.Idearium._non_persistent_indices","title":"_non_persistent_indices  <code>property</code>","text":"<pre><code>_non_persistent_indices: set\n</code></pre> <p>The indices of non-persistent notions.</p>"},{"location":"api/core/organisms/idearium/#SilverLingua.core.organisms.idearium.Idearium.validate_notions","title":"validate_notions","text":"<pre><code>validate_notions(values)\n</code></pre> Source code in <code>src/SilverLingua/core/organisms/idearium.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_notions(cls, values):\n    notions = values.notions\n    for notion in notions:\n        cls.validate_notion(notion, values.max_tokens, values.tokenizer)\n    return values\n</code></pre>"},{"location":"api/core/organisms/idearium/#SilverLingua.core.organisms.idearium.Idearium.validate_notion","title":"validate_notion  <code>classmethod</code>","text":"<pre><code>validate_notion(notion: Notion, max_tokens: int, tokenizer: Tokenizer)\n</code></pre> Source code in <code>src/SilverLingua/core/organisms/idearium.py</code> <pre><code>@classmethod\ndef validate_notion(cls, notion: Notion, max_tokens: int, tokenizer: Tokenizer):\n    if len(notion.content) == 0:\n        raise ValueError(\"Notion content cannot be empty.\")\n\n    tokenized_notion = tokenizer.encode(notion.content)\n    if len(tokenized_notion) &gt; max_tokens:\n        raise ValueError(\"Notion exceeds maximum token length\")\n\n    return tokenized_notion\n</code></pre>"},{"location":"api/core/organisms/idearium/#SilverLingua.core.organisms.idearium.Idearium.index","title":"index","text":"<pre><code>index(notion: Notion) -&gt; int\n</code></pre> <p>Returns the index of the first occurrence of the given notion.</p> Source code in <code>src/SilverLingua/core/organisms/idearium.py</code> <pre><code>def index(self, notion: Notion) -&gt; int:\n    \"\"\"Returns the index of the first occurrence of the given notion.\"\"\"\n    return self.notions.index(notion)\n</code></pre>"},{"location":"api/core/organisms/idearium/#SilverLingua.core.organisms.idearium.Idearium.append","title":"append","text":"<pre><code>append(notion: Notion)\n</code></pre> <p>Appends the given notion to the end of the Idearium.</p> Source code in <code>src/SilverLingua/core/organisms/idearium.py</code> <pre><code>def append(self, notion: Notion):\n    \"\"\"Appends the given notion to the end of the Idearium.\"\"\"\n    logger.debug(f\"Appending notion: {notion.content!r}\")\n    tokenized_notion = self.tokenizer.encode(notion.content)\n\n    if self.notions:\n        logger.debug(f\"Current last notion: {self.notions[-1].content!r}\")\n\n    if (\n        self.notions\n        and self.notions[-1].role == notion.role\n        and self.notions[-1].persistent == notion.persistent\n    ):\n        combined_content = self.notions[-1].content + notion.content\n        combined_notion = Notion(\n            content=combined_content,\n            role=notion.role,\n            persistent=notion.persistent,\n        )\n        self.replace(len(self.notions) - 1, combined_notion)\n        logger.debug(\n            f\"After replace, about to return combined content: {combined_content!r}\"\n        )\n        return\n\n    logger.debug(f\"Hitting append path. Appending new notion: {notion.content!r}\")\n    self.notions.append(notion)\n    self.tokenized_notions.append(tokenized_notion)\n\n    if notion.persistent:\n        # Modify the set in place instead of reassigning\n        self.persistent_indices.add(len(self.notions) - 1)\n\n    self._trim()\n</code></pre>"},{"location":"api/core/organisms/idearium/#SilverLingua.core.organisms.idearium.Idearium.extend","title":"extend","text":"<pre><code>extend(notions: Union[List[Notion], Idearium])\n</code></pre> <p>Extends the Idearium with the given list of notions.</p> Source code in <code>src/SilverLingua/core/organisms/idearium.py</code> <pre><code>def extend(self, notions: Union[List[Notion], \"Idearium\"]):\n    \"\"\"Extends the Idearium with the given list of notions.\"\"\"\n    if isinstance(notions, Idearium):\n        notions = notions.notions\n\n    for notion in notions:\n        self.append(notion)\n</code></pre>"},{"location":"api/core/organisms/idearium/#SilverLingua.core.organisms.idearium.Idearium.insert","title":"insert","text":"<pre><code>insert(index: int, notion: Notion)\n</code></pre> <p>Inserts the given notion at the given index.</p> Source code in <code>src/SilverLingua/core/organisms/idearium.py</code> <pre><code>def insert(self, index: int, notion: Notion):\n    \"\"\"Inserts the given notion at the given index.\"\"\"\n    tokenized_notion = self.tokenizer.encode(notion.content)\n\n    self.notions.insert(index, notion)\n    self.tokenized_notions.insert(index, tokenized_notion)\n\n    # Update persistent_indices in place\n    new_indices = {i + 1 if i &gt;= index else i for i in self.persistent_indices}\n    self.persistent_indices.clear()\n    self.persistent_indices.update(new_indices)\n    if notion.persistent:\n        self.persistent_indices.add(index)\n\n    self._trim()\n</code></pre>"},{"location":"api/core/organisms/idearium/#SilverLingua.core.organisms.idearium.Idearium.remove","title":"remove","text":"<pre><code>remove(notion: Notion)\n</code></pre> <p>Removes the first occurrence of the given notion.</p> Source code in <code>src/SilverLingua/core/organisms/idearium.py</code> <pre><code>def remove(self, notion: Notion):\n    \"\"\"Removes the first occurrence of the given notion.\"\"\"\n    index = self.index(notion)\n    self.pop(index)\n</code></pre>"},{"location":"api/core/organisms/idearium/#SilverLingua.core.organisms.idearium.Idearium.pop","title":"pop","text":"<pre><code>pop(index: int) -&gt; Notion\n</code></pre> <p>Removes and returns the notion at the given index.</p> Source code in <code>src/SilverLingua/core/organisms/idearium.py</code> <pre><code>def pop(self, index: int) -&gt; Notion:\n    \"\"\"Removes and returns the notion at the given index.\"\"\"\n    ret = self.notions.pop(index)\n    self.tokenized_notions.pop(index)\n\n    # Update persistent_indices\n    # Modify the set in place instead of reassigning\n    self.persistent_indices.discard(index)\n    new_indices = {i - 1 if i &gt; index else i for i in self.persistent_indices}\n    self.persistent_indices.clear()\n    self.persistent_indices.update(new_indices)\n\n    return ret\n</code></pre>"},{"location":"api/core/organisms/idearium/#SilverLingua.core.organisms.idearium.Idearium.replace","title":"replace","text":"<pre><code>replace(index: int, notion: Notion)\n</code></pre> <p>Replaces the notion at the given index with the given notion.</p> Source code in <code>src/SilverLingua/core/organisms/idearium.py</code> <pre><code>def replace(self, index: int, notion: Notion):\n    \"\"\"Replaces the notion at the given index with the given notion.\"\"\"\n    self.notions[index] = notion\n    self.tokenized_notions[index] = self.tokenizer.encode(notion.content)\n\n    # Update persistent_indices based on the replaced notion\n    if notion.persistent:\n        self.persistent_indices.add(index)\n    else:\n        self.persistent_indices.discard(index)\n\n    self._trim()\n</code></pre>"},{"location":"api/core/organisms/idearium/#SilverLingua.core.organisms.idearium.Idearium.copy","title":"copy","text":"<pre><code>copy() -&gt; Idearium\n</code></pre> <p>Returns a copy of the Idearium.</p> Source code in <code>src/SilverLingua/core/organisms/idearium.py</code> <pre><code>def copy(self) -&gt; \"Idearium\":\n    \"\"\"Returns a copy of the Idearium.\"\"\"\n    return Idearium(\n        tokenizer=self.tokenizer,\n        max_tokens=self.max_tokens,\n        notions=self.notions.copy(),\n        tokenized_notions=self.tokenized_notions.copy(),\n        persistent_indices=self.persistent_indices.copy(),\n    )\n</code></pre>"},{"location":"api/core/organisms/idearium/#SilverLingua.core.organisms.idearium.Idearium._trim","title":"_trim","text":"<pre><code>_trim()\n</code></pre> <p>Trims the Idearium to fit within the maximum number of tokens, called after every modification.</p> <p>This is the primary point of extension for Idearium subclasses, as it allows for custom trimming behavior.</p> Source code in <code>src/SilverLingua/core/organisms/idearium.py</code> <pre><code>def _trim(self):\n    \"\"\"\n    Trims the Idearium to fit within the maximum number of tokens, called\n    after every modification.\n\n    This is the primary point of extension for Idearium subclasses, as it\n    allows for custom trimming behavior.\n    \"\"\"\n    while self.total_tokens &gt; self.max_tokens:\n        non_persistent_indices = self._non_persistent_indices\n\n        # Check if there's only one non-persistent user message\n        if len(non_persistent_indices) == 1:\n            single_index = next(iter(non_persistent_indices))\n            tokenized_notion = self.tokenized_notions[single_index]\n\n            # Trim the only non-persistent notion to fit within the token limit\n            tokenized_notion = tokenized_notion[\n                : self.max_tokens - (self.total_tokens - len(tokenized_notion))\n            ]\n            trimmed_content = self.tokenizer.decode(tokenized_notion)\n            trimmed_notion = Notion(\n                content=trimmed_content,\n                role=self.notions[single_index].role,\n                persistent=self.notions[single_index].persistent,\n            )\n            self.replace(single_index, trimmed_notion)\n            return\n\n        # Attempt to remove the first non-persistent notion\n        for i in non_persistent_indices:\n            self.pop(i)\n            break\n        else:\n            # If all notions are persistent and\n            # the max token length is still exceeded\n            raise ValueError(\n                \"Persistent notions exceed max_tokens.\"\n                + \" Reduce the content or increase max_tokens.\"\n            )\n</code></pre>"},{"location":"api/core/templates/","title":"index","text":""},{"location":"api/core/templates/#SilverLingua.core.templates","title":"templates","text":"<p>Templates define core interfaces and abstract base classes that ensure consistency across  the system. They establish patterns that other components must follow while keeping  implementation details flexible.</p> <p>See Design Principles - Templates for more details.</p>"},{"location":"api/core/templates/#SilverLingua.core.templates.Agent","title":"Agent","text":"<pre><code>Agent(model: Model, idearium: Optional[Idearium] = None, tools: Optional[List[Tool]] = None, auto_append_response: bool = True)\n</code></pre> <p>               Bases: <code>BaseModel</code></p> <p>A wrapper around a <code>Model</code> that utilizes an <code>Idearium</code> and a set of <code>Tool</code>s.</p> <p>This is a base class not meant to be used directly. It is meant to be subclassed by specific model implementations.</p> <p>However, there is limited boilerplate. The only thing that needs to be redefined in subclasses is the <code>_bind_tools</code> method.</p> <p>Additionally, the <code>_use_tools</code> method is a common method to redefine.</p> <p>Initializes the agent.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The model to use.</p> required <code>idearium</code> <code>Idearium</code> <p>The idearium to use. If None, a new one will be created.</p> <code>None</code> <code>tools</code> <code>List[Tool]</code> <p>The tools to use.</p> <code>None</code> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>def __init__(\n    self,\n    model: Model,\n    idearium: Optional[Idearium] = None,\n    tools: Optional[List[Tool]] = None,\n    auto_append_response: bool = True,\n):\n    \"\"\"\n    Initializes the agent.\n\n    Args:\n        model (Model): The model to use.\n        idearium (Idearium, optional): The idearium to use.\n            If None, a new one will be created.\n        tools (List[Tool], optional): The tools to use.\n    \"\"\"\n    super().__init__(\n        model=model,\n        idearium=idearium\n        or Idearium(tokenizer=model.tokenizer, max_tokens=model.max_tokens),\n        tools=tools or [],\n        auto_append_response=auto_append_response,\n    )\n</code></pre>"},{"location":"api/core/templates/#SilverLingua.core.templates.Agent.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(frozen=True)\n</code></pre>"},{"location":"api/core/templates/#SilverLingua.core.templates.Agent.model","title":"model  <code>property</code>","text":"<pre><code>model: Model\n</code></pre> <p>The model used by the agent.</p>"},{"location":"api/core/templates/#SilverLingua.core.templates.Agent.idearium","title":"idearium  <code>instance-attribute</code>","text":"<pre><code>idearium: Idearium\n</code></pre> <p>The Idearium used by the agent.</p>"},{"location":"api/core/templates/#SilverLingua.core.templates.Agent.tools","title":"tools  <code>instance-attribute</code>","text":"<pre><code>tools: List[Tool]\n</code></pre> <p>The tools used by the agent.</p> Warning <p>Do not modify this list directly. Use <code>add_tool</code>, <code>add_tools</code>, and <code>remove_tool</code> instead.</p>"},{"location":"api/core/templates/#SilverLingua.core.templates.Agent.auto_append_response","title":"auto_append_response  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>auto_append_response: bool = True\n</code></pre> <p>Whether to automatically append the response to the idearium after generating a response.</p>"},{"location":"api/core/templates/#SilverLingua.core.templates.Agent.role","title":"role  <code>property</code>","text":"<pre><code>role: ChatRole\n</code></pre> <p>The ChatRole object for the model.</p>"},{"location":"api/core/templates/#SilverLingua.core.templates.Agent.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__content)\n</code></pre> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>def model_post_init(self, __content):\n    self._bind_tools()\n</code></pre>"},{"location":"api/core/templates/#SilverLingua.core.templates.Agent._find_tool","title":"_find_tool","text":"<pre><code>_find_tool(name: str) -&gt; Tool | None\n</code></pre> <p>Finds a tool by name.</p> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>def _find_tool(self, name: str) -&gt; Tool | None:\n    \"\"\"\n    Finds a tool by name.\n    \"\"\"\n    for t in self.tools:\n        if t.name == name:\n            return t\n    return None\n</code></pre>"},{"location":"api/core/templates/#SilverLingua.core.templates.Agent._use_tools","title":"_use_tools","text":"<pre><code>_use_tools(tool_calls: ToolCalls) -&gt; List[Notion]\n</code></pre> <p>Uses Tools based on the given ToolCalls, returning Notions containing ToolCallResponses.</p> <p>Parameters:</p> Name Type Description Default <code>tool_calls</code> <code>ToolCalls</code> <p>The ToolCalls to use.</p> required <p>Returns:</p> Type Description <code>List[Notion]</code> <p>List[Notion]: The Notions containing ToolCallResponses. Each Notion will have a role of ChatRole.TOOL_RESPONSE.</p> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>def _use_tools(self, tool_calls: ToolCalls) -&gt; List[Notion]:\n    \"\"\"\n    Uses Tools based on the given ToolCalls, returning Notions\n    containing ToolCallResponses.\n\n    Args:\n        tool_calls (ToolCalls): The ToolCalls to use.\n\n    Returns:\n        List[Notion]: The Notions containing ToolCallResponses.\n            Each Notion will have a role of ChatRole.TOOL_RESPONSE.\n    \"\"\"\n    responses: List[Notion] = []\n    for tool_call in tool_calls.list:\n        tool = self._find_tool(tool_call.function.name)\n        if tool is not None:\n            tc_function_response = {}\n            with contextlib.suppress(json.JSONDecodeError):\n                tc_function_response = json.loads(tool_call.function.arguments)\n\n            tc_response = ToolCallResponse.from_tool_call(\n                tool_call=tool_call, response=tool(**tc_function_response)\n            )\n            responses.append(\n                Notion(\n                    content=tc_response.model_dump_json(exclude_none=True),\n                    role=str(self.role.TOOL_RESPONSE.value),\n                )\n            )\n        else:\n            responses.append(\n                Notion(\n                    content=json.dumps(\n                        {\n                            \"tool_call_id\": tool_call.id,\n                            \"content\": \"Tool not found\",\n                            \"name\": \"error\",\n                        }\n                    ),\n                    role=str(self.role.TOOL_RESPONSE.value),\n                )\n            )\n    return responses\n</code></pre>"},{"location":"api/core/templates/#SilverLingua.core.templates.Agent._bind_tools","title":"_bind_tools","text":"<pre><code>_bind_tools() -&gt; None\n</code></pre> <p>Called at the end of init to bind the tools to the model.</p> <p>This MUST be redefined in subclasses to dictate how the tools are bound to the model.</p> <p>Example: <pre><code># From OpenAIChatAgent\ndef _bind_tools(self) -&gt; None:\n    m_tools: List[ChatCompletionToolParam] = [\n        {\"type\": \"function\", \"function\": tool.description}\n        for tool in self.tools\n    ]\n\n    if len(m_tools) &gt; 0:\n        self.model.tools = m_tools\n</code></pre></p> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>def _bind_tools(self) -&gt; None:\n    \"\"\"\n    Called at the end of __init__ to bind the tools to the model.\n\n    This MUST be redefined in subclasses to dictate how\n    the tools are bound to the model.\n\n    Example:\n    ```python\n    # From OpenAIChatAgent\n    def _bind_tools(self) -&gt; None:\n        m_tools: List[ChatCompletionToolParam] = [\n            {\"type\": \"function\", \"function\": tool.description}\n            for tool in self.tools\n        ]\n\n        if len(m_tools) &gt; 0:\n            self.model.tools = m_tools\n    ```\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/templates/#SilverLingua.core.templates.Agent.add_tool","title":"add_tool","text":"<pre><code>add_tool(tool: Tool) -&gt; None\n</code></pre> <p>Adds a tool to the agent.</p> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>def add_tool(self, tool: Tool) -&gt; None:\n    \"\"\"\n    Adds a tool to the agent.\n    \"\"\"\n    self.tools.append(tool)\n    self._bind_tools()\n</code></pre>"},{"location":"api/core/templates/#SilverLingua.core.templates.Agent.add_tools","title":"add_tools","text":"<pre><code>add_tools(tools: List[Tool]) -&gt; None\n</code></pre> <p>Adds a list of tools to the agent.</p> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>def add_tools(self, tools: List[Tool]) -&gt; None:\n    \"\"\"\n    Adds a list of tools to the agent.\n    \"\"\"\n    self.tools.extend(tools)\n    self._bind_tools()\n</code></pre>"},{"location":"api/core/templates/#SilverLingua.core.templates.Agent.remove_tool","title":"remove_tool","text":"<pre><code>remove_tool(name: str) -&gt; None\n</code></pre> <p>Removes a tool from the agent.</p> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>def remove_tool(self, name: str) -&gt; None:\n    \"\"\"\n    Removes a tool from the agent.\n    \"\"\"\n    for i, tool in enumerate(self.tools):\n        if tool.name == name:\n            self.tools.pop(i)\n            break\n    self._bind_tools()\n</code></pre>"},{"location":"api/core/templates/#SilverLingua.core.templates.Agent._process_messages","title":"_process_messages","text":"<pre><code>_process_messages(messages: Messages) -&gt; List[Notion]\n</code></pre> <p>Convert various message types into a list of Notions.</p> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>def _process_messages(self, messages: Messages) -&gt; List[Notion]:\n    \"\"\"Convert various message types into a list of Notions.\"\"\"\n    if isinstance(messages, str):\n        return [Notion(content=messages, role=str(self.role.HUMAN.value))]\n    elif isinstance(messages, Notion):\n        return [messages]\n    elif isinstance(messages, Idearium):\n        return messages.notions\n    elif isinstance(messages, list):\n        return [\n            (\n                Notion(content=msg, role=str(self.role.HUMAN.value))\n                if isinstance(msg, str)\n                else msg\n            )\n            for msg in messages\n        ]\n    raise ValueError(f\"Unsupported message type: {type(messages)}\")\n</code></pre>"},{"location":"api/core/templates/#SilverLingua.core.templates.Agent._process_generation","title":"_process_generation","text":"<pre><code>_process_generation(responses: List[Notion], is_async=False) -&gt; List[Notion]\n</code></pre> <p>Wrapper around shared logic between generate and agenerate.</p> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>def _process_generation(\n    self, responses: List[Notion], is_async=False\n) -&gt; List[Notion]:\n    \"\"\"Wrapper around shared logic between generate and agenerate.\"\"\"\n    response = responses[0]\n    # logger.debug(f\"Response: {response}\")\n    if response.chat_role == ChatRole.TOOL_CALL:\n        # logger.debug(\"Tool call detected\")\n        # Add the tool call to the idearium\n        self.idearium.append(response)\n        # Call generate again with the tool response\n        tool_calls = ToolCalls.model_validate_json(\n            '{\"list\": ' + response.content + \"}\"\n        )\n        tool_response = self._use_tools(tool_calls)\n        # logger.debug(f\"Tool response: {tool_response}\")\n        if is_async:\n            return self.agenerate(tool_response)\n        else:\n            return self.generate(tool_response)\n    else:\n        return responses\n</code></pre>"},{"location":"api/core/templates/#SilverLingua.core.templates.Agent.generate","title":"generate","text":"<pre><code>generate(messages: Messages, **kwargs) -&gt; List[Notion]\n</code></pre> <p>Generates a response to the given messages by calling the underlying model's generate method and checking/actualizing tool usage.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>Union[str, Notion, Idearium, List[Union[str, Notion]]]</code> required <p>Returns:</p> Type Description <code>List[Notion]</code> <p>List[Notion]: A list of responses to the given messages. (Many times there will only be one response.)</p> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>def generate(self, messages: Messages, **kwargs) -&gt; List[Notion]:\n    \"\"\"\n    Generates a response to the given messages by calling the\n    underlying model's generate method and checking/actualizing tool usage.\n\n    Args:\n        messages (Union[str, Notion, Idearium, List[Union[str, Notion]]]):\n        The messages to respond to.\n\n    Returns:\n        List[Notion]: A list of responses to the given messages.\n            (Many times there will only be one response.)\n    \"\"\"\n    self.idearium.extend(self._process_messages(messages))\n    responses = self.model.generate(self.idearium, **kwargs)\n    result = self._process_generation(responses)\n\n    if self.auto_append_response:\n        self.idearium.extend(result)\n\n    return result\n</code></pre>"},{"location":"api/core/templates/#SilverLingua.core.templates.Agent.agenerate","title":"agenerate  <code>async</code>","text":"<pre><code>agenerate(messages: Messages, **kwargs) -&gt; List[Notion]\n</code></pre> <p>Asynchronously generates a response to the given messages by calling the underlying model's agenerate method and checking/actualizing tool usage.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>Union[str, Notion, Idearium, List[Union[str, Notion]]]</code> required <p>Returns:</p> Type Description <code>List[Notion]</code> <p>List[Notion]: A list of responses to the given messages. (Many times there will only be one response.)</p> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>async def agenerate(self, messages: Messages, **kwargs) -&gt; List[Notion]:\n    \"\"\"\n    Asynchronously generates a response to the given messages by calling the\n    underlying model's agenerate method and checking/actualizing tool usage.\n\n    Args:\n        messages (Union[str, Notion, Idearium, List[Union[str, Notion]]]):\n        The messages to respond to.\n\n    Returns:\n        List[Notion]: A list of responses to the given messages.\n            (Many times there will only be one response.)\n    \"\"\"\n    self.idearium.extend(self._process_messages(messages))\n    responses = await self.model.agenerate(self.idearium, **kwargs)\n    result = self._process_generation(responses, True)\n    r = await result if asyncio.iscoroutine(result) else result\n\n    if self.auto_append_response:\n        self.idearium.extend(r)\n\n    return r\n</code></pre>"},{"location":"api/core/templates/#SilverLingua.core.templates.Agent._process_tool_calls","title":"_process_tool_calls","text":"<pre><code>_process_tool_calls(tool_calls: ToolCalls)\n</code></pre> <p>Processes tool calls and returns the tool response.</p> <p>Parameters:</p> Name Type Description Default <code>tool_calls</code> <code>ToolCalls</code> <p>The tool calls to process.</p> required <p>Returns:</p> Type Description <p>Optional[ToolCalls]: The tool response. If None, no tool calls were found.</p> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>def _process_tool_calls(self, tool_calls: ToolCalls):\n    \"\"\"\n    Processes tool calls and returns the tool response.\n\n    Args:\n        tool_calls (ToolCalls): The tool calls to process.\n\n    Returns:\n        Optional[ToolCalls]: The tool response. If None, no tool calls were found.\n    \"\"\"\n    for i, tool_call in enumerate(tool_calls.list):\n        if not tool_call.id.startswith(\"call_\"):\n            # Something went wrong and this tool call is not valid\n            tool_calls.list.pop(i)\n            logger.error(\n                \"Invalid tool call: \"\n                + f\"{tool_call.model_dump_json(exclude_none=True)}\"\n            )\n\n    tc_dump = tool_calls.model_dump(exclude_none=True)\n    if tc_dump.get(\"list\"):\n        logger.debug(f\"Tool calls: {tc_dump}\")\n\n        # Create a new notion from the tool calls\n        tc_notion = Notion(\n            content=json.dumps(tc_dump.get(\"list\")),\n            role=str(ChatRole.TOOL_CALL.value),\n        )\n\n        # Add the tool call to the idearium\n        self.idearium.append(tc_notion)\n        # Call stream again with the tool response\n        tool_response = self._use_tools(tool_calls)\n        return tool_response\n    else:\n        logger.error(\"No tool calls found\")\n        return None\n</code></pre>"},{"location":"api/core/templates/#SilverLingua.core.templates.Agent.stream","title":"stream","text":"<pre><code>stream(messages: Messages, **kwargs)\n</code></pre> <p>Streams a response to the given prompt by calling the underlying model's stream method and checking/actualizing tool usage.</p> <p>NOTE: Will raise an exception if the underlying model does not support streaming.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>Union[str, Notion, Idearium, List[Union[str, Notion]]]</code> required <p>Returns:</p> Type Description <p>Generator[Notion, Any, None]: A generator of responses to the given messages.</p> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>def stream(self, messages: Messages, **kwargs):\n    \"\"\"\n    Streams a response to the given prompt by calling the\n    underlying model's stream method and checking/actualizing tool usage.\n\n    NOTE: Will raise an exception if the underlying model does not support\n    streaming.\n\n    Args:\n        messages (Union[str, Notion, Idearium, List[Union[str, Notion]]]):\n        The messages to respond to.\n\n    Returns:\n        Generator[Notion, Any, None]: A generator of responses to the given\n            messages.\n    \"\"\"\n    self.idearium.extend(self._process_messages(messages))\n    response_stream = self.model.stream(self.idearium, **kwargs)\n\n    # Process stream directly\n    tool_calls: Optional[ToolCalls] = None\n\n    for r in response_stream:\n        if r.chat_role == ChatRole.TOOL_CALL:\n            logger.debug(f\"Tool call detected: {r.content}\")\n            tc_chunks = ToolCalls.model_validate_json('{\"list\": ' + r.content + \"}\")\n            tool_calls = tool_calls and tool_calls.concat(tc_chunks) or tc_chunks\n            continue\n        elif r.content is not None:\n            logger.debug(f\"Got chunk in stream: {r.content!r}\")\n            if self.auto_append_response:\n                self.idearium.append(r)\n            yield r\n\n    # Handle tool calls if any\n    if tool_calls is not None:\n        logger.debug(\"Moving to tool response stream\")\n        tool_response = self._process_tool_calls(tool_calls)\n        if tool_response is not None:\n            for r in self.stream(tool_response):\n                yield r\n</code></pre>"},{"location":"api/core/templates/#SilverLingua.core.templates.Agent.astream","title":"astream  <code>async</code>","text":"<pre><code>astream(messages: Messages, **kwargs)\n</code></pre> <p>Asynchronously streams a response to the given prompt by calling the underlying model's astream method and checking/actualizing tool usage.</p> <p>NOTE: Will raise an exception if the underlying model does not support streaming.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>Union[str, Notion, Idearium, List[Union[str, Notion]]]</code> required <p>Returns:</p> Type Description <p>Generator[Notion, Any, None]: A generator of responses to the given messages.</p> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>async def astream(self, messages: Messages, **kwargs):\n    \"\"\"\n    Asynchronously streams a response to the given prompt by calling the\n    underlying model's astream method and checking/actualizing tool usage.\n\n    NOTE: Will raise an exception if the underlying model does not support\n    streaming.\n\n    Args:\n        messages (Union[str, Notion, Idearium, List[Union[str, Notion]]]):\n        The messages to respond to.\n\n    Returns:\n        Generator[Notion, Any, None]: A generator of responses to the given\n            messages.\n    \"\"\"\n    self.idearium.extend(self._process_messages(messages))\n    response_stream = self.model.astream(self.idearium, **kwargs)\n\n    # Process stream directly\n    tool_calls: Optional[ToolCalls] = None\n\n    async for r in response_stream:\n        if r.chat_role == ChatRole.TOOL_CALL:\n            logger.debug(f\"Tool call detected: {r.content}\")\n            tc_chunks = ToolCalls.model_validate_json('{\"list\": ' + r.content + \"}\")\n            tool_calls = tool_calls and tool_calls.concat(tc_chunks) or tc_chunks\n            continue\n        elif r.content is not None:\n            logger.debug(f\"Got chunk in astream: {r.content!r}\")\n            if self.auto_append_response:\n                self.idearium.append(r)\n            yield r\n\n    # Handle tool calls if any\n    if tool_calls is not None:\n        logger.debug(\"Moving to tool response stream\")\n        tool_response = self._process_tool_calls(tool_calls)\n        if tool_response is not None:\n            async for r in self.astream(tool_response):\n                yield r\n</code></pre>"},{"location":"api/core/templates/#SilverLingua.core.templates.Model","title":"Model","text":"<p>               Bases: <code>BaseModel</code>, <code>ABC</code></p> <p>Abstract class for all Large Language Models.</p> <p>This class outlines a standardized lifecycle for interacting with LLMs, aimed at ensuring a consistent process for message trimming, pre-processing, preparing requests for the model, invoking the model, standardizing the response, and post-processing. The lifecycle is as follows:</p> Lifecycle <ol> <li> <p>Pre-processing (<code>_preprocess</code>): Performs any necessary transformations or     adjustments to the messages prior to trimming or preparing them for model input.     (Optional)</p> </li> <li> <p>Preparing Request (<code>_format_request</code>): Converts the pre-processed messages     into a format suitable for model input.</p> </li> <li> <p>Model Invocation (<code>_call</code> or <code>_acall</code>): Feeds the prepared input to the LLM and     retrieves the raw model output. There should be both synchronous and     asynchronous versions available.</p> </li> <li> <p>Standardizing Response (<code>_standardize_response</code>): Transforms the raw model     output into a consistent response format suitable for further processing or     delivery.</p> </li> <li> <p>Post-processing (<code>_postprocess</code>): Performs any final transformations or     adjustments to the standardized responses, making them ready for delivery.     (Optional)</p> </li> </ol> <p>Subclasses should implement each of the non-optional lifecycle steps in accordance with the specific requirements and behaviors of the target LLM.</p> See also <ul> <li><code>Agent</code></li> <li><code>Idearium</code></li> <li><code>Notion</code></li> </ul>"},{"location":"api/core/templates/#SilverLingua.core.templates.Model.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(frozen=True)\n</code></pre>"},{"location":"api/core/templates/#SilverLingua.core.templates.Model.max_response","title":"max_response  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_response: int = Field(default=0)\n</code></pre>"},{"location":"api/core/templates/#SilverLingua.core.templates.Model.api_key","title":"api_key  <code>instance-attribute</code>","text":"<pre><code>api_key: str\n</code></pre>"},{"location":"api/core/templates/#SilverLingua.core.templates.Model.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/core/templates/#SilverLingua.core.templates.Model.role","title":"role  <code>instance-attribute</code>","text":"<pre><code>role: Type[ChatRole]\n</code></pre>"},{"location":"api/core/templates/#SilverLingua.core.templates.Model.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: ModelType\n</code></pre>"},{"location":"api/core/templates/#SilverLingua.core.templates.Model.llm","title":"llm  <code>instance-attribute</code>","text":"<pre><code>llm: Callable\n</code></pre>"},{"location":"api/core/templates/#SilverLingua.core.templates.Model.llm_async","title":"llm_async  <code>instance-attribute</code>","text":"<pre><code>llm_async: Callable\n</code></pre>"},{"location":"api/core/templates/#SilverLingua.core.templates.Model.can_stream","title":"can_stream  <code>instance-attribute</code>","text":"<pre><code>can_stream: bool\n</code></pre>"},{"location":"api/core/templates/#SilverLingua.core.templates.Model.tokenizer","title":"tokenizer  <code>instance-attribute</code>","text":"<pre><code>tokenizer: Tokenizer\n</code></pre>"},{"location":"api/core/templates/#SilverLingua.core.templates.Model.max_tokens","title":"max_tokens  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>max_tokens: int\n</code></pre> <p>The maximum number of tokens that can be fed to the model at once.</p>"},{"location":"api/core/templates/#SilverLingua.core.templates.Model._process_input","title":"_process_input","text":"<pre><code>_process_input(messages: Messages) -&gt; Idearium\n</code></pre> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>def _process_input(self, messages: Messages) -&gt; Idearium:\n    if isinstance(messages, str):\n        notions = [Notion(content=messages, role=self.role.HUMAN)]\n    elif isinstance(messages, Notion):\n        notions = [messages]\n    elif isinstance(messages, Idearium):\n        return messages  # Already an Idearium, no need to convert\n    elif isinstance(messages, list):\n        notions = [\n            (\n                Notion(content=msg, role=self.role.HUMAN)\n                if isinstance(msg, str)\n                else msg\n            )\n            for msg in messages\n        ]\n    else:\n        raise ValueError(\"Invalid input type for messages\")\n\n    return Idearium(self.tokenizer, self.max_tokens, notions)\n</code></pre>"},{"location":"api/core/templates/#SilverLingua.core.templates.Model._convert_role","title":"_convert_role","text":"<pre><code>_convert_role(role: ChatRole) -&gt; str\n</code></pre> <p>Converts the standard ChatRole to the model-specific role.</p> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>def _convert_role(self, role: ChatRole) -&gt; str:\n    \"\"\"\n    Converts the standard ChatRole to the model-specific role.\n    \"\"\"\n    return str(self.role[role.name].value)\n</code></pre>"},{"location":"api/core/templates/#SilverLingua.core.templates.Model._preprocess","title":"_preprocess","text":"<pre><code>_preprocess(messages: List[Notion]) -&gt; List[Notion]\n</code></pre> <p>Preprocesses the List of <code>Notions</code>, applying any effects necessary before being prepped for input into an API.</p> <p>This is a lifecycle method that is called by the <code>generate</code> method.</p> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>def _preprocess(self, messages: List[Notion]) -&gt; List[Notion]:\n    \"\"\"\n    Preprocesses the List of `Notions`, applying any effects necessary\n    before being prepped for input into an API.\n\n    This is a lifecycle method that is called by the `generate` method.\n    \"\"\"\n    return [\n        Notion(msg.content, self._convert_role(msg.chat_role), msg.persistent)\n        for msg in messages\n    ]\n</code></pre>"},{"location":"api/core/templates/#SilverLingua.core.templates.Model._format_request","title":"_format_request  <code>abstractmethod</code>","text":"<pre><code>_format_request(messages: List[Notion], *args, **kwargs) -&gt; Union[str, object]\n</code></pre> <p>Formats the List of <code>Notions</code> into a format suitable for model input.</p> <p>This is a lifecycle method that is called by the <code>generate</code> method.</p> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>@abstractmethod\ndef _format_request(\n    self, messages: List[Notion], *args, **kwargs\n) -&gt; Union[str, object]:\n    \"\"\"\n    Formats the List of `Notions` into a format suitable for model input.\n\n    This is a lifecycle method that is called by the `generate` method.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/templates/#SilverLingua.core.templates.Model._standardize_response","title":"_standardize_response  <code>abstractmethod</code>","text":"<pre><code>_standardize_response(response: Union[object, str, List[any]], *args, **kwargs) -&gt; List[Notion]\n</code></pre> <p>Standardizes the raw response from the model into a List of Notions.</p> <p>This is a lifecycle method that is called by the <code>generate</code> method.</p> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>@abstractmethod\ndef _standardize_response(\n    self, response: Union[object, str, List[any]], *args, **kwargs\n) -&gt; List[Notion]:\n    \"\"\"\n    Standardizes the raw response from the model into a List of Notions.\n\n    This is a lifecycle method that is called by the `generate` method.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/templates/#SilverLingua.core.templates.Model._postprocess","title":"_postprocess  <code>abstractmethod</code>","text":"<pre><code>_postprocess(response: List[Notion], *args, **kwargs) -&gt; List[Notion]\n</code></pre> <p>Postprocesses the response from the model, applying any final effects before being returned.</p> <p>This is a lifecycle method that is called by the <code>generate</code> method.</p> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>@abstractmethod\ndef _postprocess(self, response: List[Notion], *args, **kwargs) -&gt; List[Notion]:\n    \"\"\"\n    Postprocesses the response from the model, applying any final effects\n    before being returned.\n\n    This is a lifecycle method that is called by the `generate` method.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/templates/#SilverLingua.core.templates.Model._retry_call","title":"_retry_call  <code>abstractmethod</code>","text":"<pre><code>_retry_call(input: Union[str, object, List[any]], e: Exception, api_call: Callable, retries: int = 0) -&gt; Union[str, object]\n</code></pre> <p>Retry logic for API calls used by <code>_common_call_logic</code>.</p> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>@abstractmethod\ndef _retry_call(\n    self,\n    input: Union[str, object, List[any]],\n    e: Exception,\n    api_call: Callable,\n    retries: int = 0,\n) -&gt; Union[str, object]:\n    \"\"\"\n    Retry logic for API calls used by `_common_call_logic`.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/templates/#SilverLingua.core.templates.Model._common_call_logic","title":"_common_call_logic","text":"<pre><code>_common_call_logic(input: Union[str, object, List[any]], api_call: Callable, retries: int = 0) -&gt; Union[str, object]\n</code></pre> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>def _common_call_logic(\n    self,\n    input: Union[str, object, List[any]],\n    api_call: Callable,\n    retries: int = 0,\n) -&gt; Union[str, object]:\n    if input is None:\n        raise ValueError(\"No input provided.\")\n\n    try:\n        out = api_call(messages=input)\n        return out\n    except Exception as e:\n        logger.error(f\"Error calling LLM API: {e}\")\n        if retries &gt;= 3:\n            raise e\n\n        return self._retry_call(input, e, api_call, retries=retries)\n</code></pre>"},{"location":"api/core/templates/#SilverLingua.core.templates.Model._call","title":"_call","text":"<pre><code>_call(input: Union[str, object, List[any]], retries: int = 0, **kwargs) -&gt; object\n</code></pre> <p>Calls the model with the given input and returns the raw response.</p> <p>Should behave exactly as <code>_acall</code> does, but synchronously.</p> <p>This is a lifecycle method that is called by the <code>generate</code> method.</p> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>def _call(\n    self, input: Union[str, object, List[any]], retries: int = 0, **kwargs\n) -&gt; object:\n    \"\"\"\n    Calls the model with the given input and returns the raw response.\n\n    Should behave exactly as `_acall` does, but synchronously.\n\n    This is a lifecycle method that is called by the `generate` method.\n    \"\"\"\n\n    def api_call(**kwargs_):\n        return self.llm(**kwargs_, **kwargs)\n\n    return self._common_call_logic(input, api_call, retries)\n</code></pre>"},{"location":"api/core/templates/#SilverLingua.core.templates.Model._acall","title":"_acall  <code>async</code>","text":"<pre><code>_acall(input: Union[str, object, List[any]], retries: int = 0, **kwargs) -&gt; object\n</code></pre> <p>Calls the model with the given input and returns the raw response asynchronously.</p> <p>Should behave exactly as <code>_call</code> does, but asynchronously.</p> <p>This is a lifecycle method that is called by the <code>agenerate</code> method.</p> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>async def _acall(\n    self, input: Union[str, object, List[any]], retries: int = 0, **kwargs\n) -&gt; object:\n    \"\"\"\n    Calls the model with the given input and returns the\n    raw response asynchronously.\n\n    Should behave exactly as `_call` does, but asynchronously.\n\n    This is a lifecycle method that is called by the `agenerate` method.\n    \"\"\"\n\n    async def api_call(**kwargs_):\n        return await self.llm_async(**kwargs_, **kwargs)\n\n    result = self._common_call_logic(input, api_call, retries)\n    if asyncio.iscoroutine(result):\n        return await result\n    return result\n</code></pre>"},{"location":"api/core/templates/#SilverLingua.core.templates.Model._common_generate_logic","title":"_common_generate_logic","text":"<pre><code>_common_generate_logic(messages: Messages, is_async=False, **kwargs)\n</code></pre> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>def _common_generate_logic(\n    self,\n    messages: Messages,\n    is_async=False,\n    **kwargs,\n):\n    if messages is None:\n        raise ValueError(\"No messages provided.\")\n\n    call_method = self._acall if is_async else self._call\n\n    idearium = self._process_input(messages)\n    input = self._format_request(self._preprocess(idearium))\n\n    if is_async:\n\n        async def call():\n            response = await call_method(input, **kwargs)\n            output = self._standardize_response(response)\n            return self._postprocess(output)\n\n        return call()\n    else:\n        response = call_method(input, **kwargs)\n        output = self._standardize_response(response)\n        return self._postprocess(output)\n</code></pre>"},{"location":"api/core/templates/#SilverLingua.core.templates.Model.generate","title":"generate  <code>abstractmethod</code>","text":"<pre><code>generate(messages: Messages, *args, **kwargs) -&gt; List[Notion]\n</code></pre> <p>Calls the model with the given messages and returns the response.</p> <p>Messages can be any of: string, list of strings, Notion, list of Notions, or Idearium.</p> <p>This is the primary method for generating responses from the model, and is responsible for calling all of the lifecycle methods.</p> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>@abstractmethod\ndef generate(\n    self,\n    messages: Messages,\n    *args,\n    **kwargs,\n) -&gt; List[Notion]:\n    \"\"\"\n    Calls the model with the given messages and returns the response.\n\n    Messages can be any of:\n    string, list of strings, Notion, list of Notions, or Idearium.\n\n    This is the primary method for generating responses from the model,\n    and is responsible for calling all of the lifecycle methods.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/templates/#SilverLingua.core.templates.Model.agenerate","title":"agenerate  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>agenerate(messages: Messages, *args, **kwargs) -&gt; List[Notion]\n</code></pre> <p>Calls the model with the given messages and returns the response asynchronously.</p> <p>Messages can be any of: string, list of strings, Notion, list of Notions, or Idearium.</p> <p>This is the primary method for generating async responses from the model, and is responsible for calling all of the lifecycle methods.</p> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>@abstractmethod\nasync def agenerate(\n    self,\n    messages: Messages,\n    *args,\n    **kwargs,\n) -&gt; List[Notion]:\n    \"\"\"\n    Calls the model with the given messages and returns the response\n    asynchronously.\n\n    Messages can be any of:\n    string, list of strings, Notion, list of Notions, or Idearium.\n\n    This is the primary method for generating async responses from the model,\n    and is responsible for calling all of the lifecycle methods.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/templates/#SilverLingua.core.templates.Model._common_stream_logic","title":"_common_stream_logic","text":"<pre><code>_common_stream_logic(messages: Messages)\n</code></pre> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>def _common_stream_logic(self, messages: Messages):\n    if messages is None:\n        raise ValueError(\"No messages provided.\")\n\n    if not self.can_stream:\n        raise ValueError(\n            \"This model does not support streaming. \"\n            + \"Please use the `generate` method instead.\"\n        )\n\n    idearium = self._process_input(messages)\n    input = self._format_request(self._preprocess(idearium))\n    return input\n</code></pre>"},{"location":"api/core/templates/#SilverLingua.core.templates.Model.stream","title":"stream  <code>abstractmethod</code>","text":"<pre><code>stream(messages: Messages, *args, **kwargs) -&gt; Generator[Notion, Any, None]\n</code></pre> <p>Streams the model with the given messages and returns the response, one token at a time.</p> <p>Messages can be any of: string, list of strings, Notion, list of Notions, or Idearium.</p> <p>If the model cannot be streamed, this will raise an exception.</p> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>@abstractmethod\ndef stream(\n    self, messages: Messages, *args, **kwargs\n) -&gt; Generator[Notion, Any, None]:\n    \"\"\"\n    Streams the model with the given messages and returns the response,\n    one token at a time.\n\n    Messages can be any of:\n    string, list of strings, Notion, list of Notions, or Idearium.\n\n    If the model cannot be streamed, this will raise an exception.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/templates/#SilverLingua.core.templates.Model.astream","title":"astream  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>astream(messages: Messages, *args, **kwargs) -&gt; Generator[Notion, Any, None]\n</code></pre> <p>Streams the model with the given messages and returns the response, one token at a time, asynchronously.</p> <p>Messages can be any of: string, list of strings, Notion, list of Notions, or Idearium.</p> <p>If the model cannot be streamed, this will raise an exception.</p> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>@abstractmethod\nasync def astream(\n    self, messages: Messages, *args, **kwargs\n) -&gt; Generator[Notion, Any, None]:\n    \"\"\"\n    Streams the model with the given messages and returns the response,\n    one token at a time, asynchronously.\n\n    Messages can be any of:\n    string, list of strings, Notion, list of Notions, or Idearium.\n\n    If the model cannot be streamed, this will raise an exception.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/templates/agent/","title":"Agent","text":""},{"location":"api/core/templates/agent/#SilverLingua.core.templates.agent","title":"agent","text":""},{"location":"api/core/templates/agent/#SilverLingua.core.templates.agent.Agent","title":"Agent","text":"<pre><code>Agent(model: Model, idearium: Optional[Idearium] = None, tools: Optional[List[Tool]] = None, auto_append_response: bool = True)\n</code></pre> <p>               Bases: <code>BaseModel</code></p> <p>A wrapper around a <code>Model</code> that utilizes an <code>Idearium</code> and a set of <code>Tool</code>s.</p> <p>This is a base class not meant to be used directly. It is meant to be subclassed by specific model implementations.</p> <p>However, there is limited boilerplate. The only thing that needs to be redefined in subclasses is the <code>_bind_tools</code> method.</p> <p>Additionally, the <code>_use_tools</code> method is a common method to redefine.</p> <p>Initializes the agent.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The model to use.</p> required <code>idearium</code> <code>Idearium</code> <p>The idearium to use. If None, a new one will be created.</p> <code>None</code> <code>tools</code> <code>List[Tool]</code> <p>The tools to use.</p> <code>None</code> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>def __init__(\n    self,\n    model: Model,\n    idearium: Optional[Idearium] = None,\n    tools: Optional[List[Tool]] = None,\n    auto_append_response: bool = True,\n):\n    \"\"\"\n    Initializes the agent.\n\n    Args:\n        model (Model): The model to use.\n        idearium (Idearium, optional): The idearium to use.\n            If None, a new one will be created.\n        tools (List[Tool], optional): The tools to use.\n    \"\"\"\n    super().__init__(\n        model=model,\n        idearium=idearium\n        or Idearium(tokenizer=model.tokenizer, max_tokens=model.max_tokens),\n        tools=tools or [],\n        auto_append_response=auto_append_response,\n    )\n</code></pre>"},{"location":"api/core/templates/agent/#SilverLingua.core.templates.agent.Agent.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(frozen=True)\n</code></pre>"},{"location":"api/core/templates/agent/#SilverLingua.core.templates.agent.Agent.idearium","title":"idearium  <code>instance-attribute</code>","text":"<pre><code>idearium: Idearium\n</code></pre> <p>The Idearium used by the agent.</p>"},{"location":"api/core/templates/agent/#SilverLingua.core.templates.agent.Agent.tools","title":"tools  <code>instance-attribute</code>","text":"<pre><code>tools: List[Tool]\n</code></pre> <p>The tools used by the agent.</p> Warning <p>Do not modify this list directly. Use <code>add_tool</code>, <code>add_tools</code>, and <code>remove_tool</code> instead.</p>"},{"location":"api/core/templates/agent/#SilverLingua.core.templates.agent.Agent.auto_append_response","title":"auto_append_response  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>auto_append_response: bool = True\n</code></pre> <p>Whether to automatically append the response to the idearium after generating a response.</p>"},{"location":"api/core/templates/agent/#SilverLingua.core.templates.agent.Agent.model","title":"model  <code>property</code>","text":"<pre><code>model: Model\n</code></pre> <p>The model used by the agent.</p>"},{"location":"api/core/templates/agent/#SilverLingua.core.templates.agent.Agent.role","title":"role  <code>property</code>","text":"<pre><code>role: ChatRole\n</code></pre> <p>The ChatRole object for the model.</p>"},{"location":"api/core/templates/agent/#SilverLingua.core.templates.agent.Agent.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__content)\n</code></pre> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>def model_post_init(self, __content):\n    self._bind_tools()\n</code></pre>"},{"location":"api/core/templates/agent/#SilverLingua.core.templates.agent.Agent._find_tool","title":"_find_tool","text":"<pre><code>_find_tool(name: str) -&gt; Tool | None\n</code></pre> <p>Finds a tool by name.</p> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>def _find_tool(self, name: str) -&gt; Tool | None:\n    \"\"\"\n    Finds a tool by name.\n    \"\"\"\n    for t in self.tools:\n        if t.name == name:\n            return t\n    return None\n</code></pre>"},{"location":"api/core/templates/agent/#SilverLingua.core.templates.agent.Agent._use_tools","title":"_use_tools","text":"<pre><code>_use_tools(tool_calls: ToolCalls) -&gt; List[Notion]\n</code></pre> <p>Uses Tools based on the given ToolCalls, returning Notions containing ToolCallResponses.</p> <p>Parameters:</p> Name Type Description Default <code>tool_calls</code> <code>ToolCalls</code> <p>The ToolCalls to use.</p> required <p>Returns:</p> Type Description <code>List[Notion]</code> <p>List[Notion]: The Notions containing ToolCallResponses. Each Notion will have a role of ChatRole.TOOL_RESPONSE.</p> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>def _use_tools(self, tool_calls: ToolCalls) -&gt; List[Notion]:\n    \"\"\"\n    Uses Tools based on the given ToolCalls, returning Notions\n    containing ToolCallResponses.\n\n    Args:\n        tool_calls (ToolCalls): The ToolCalls to use.\n\n    Returns:\n        List[Notion]: The Notions containing ToolCallResponses.\n            Each Notion will have a role of ChatRole.TOOL_RESPONSE.\n    \"\"\"\n    responses: List[Notion] = []\n    for tool_call in tool_calls.list:\n        tool = self._find_tool(tool_call.function.name)\n        if tool is not None:\n            tc_function_response = {}\n            with contextlib.suppress(json.JSONDecodeError):\n                tc_function_response = json.loads(tool_call.function.arguments)\n\n            tc_response = ToolCallResponse.from_tool_call(\n                tool_call=tool_call, response=tool(**tc_function_response)\n            )\n            responses.append(\n                Notion(\n                    content=tc_response.model_dump_json(exclude_none=True),\n                    role=str(self.role.TOOL_RESPONSE.value),\n                )\n            )\n        else:\n            responses.append(\n                Notion(\n                    content=json.dumps(\n                        {\n                            \"tool_call_id\": tool_call.id,\n                            \"content\": \"Tool not found\",\n                            \"name\": \"error\",\n                        }\n                    ),\n                    role=str(self.role.TOOL_RESPONSE.value),\n                )\n            )\n    return responses\n</code></pre>"},{"location":"api/core/templates/agent/#SilverLingua.core.templates.agent.Agent._bind_tools","title":"_bind_tools","text":"<pre><code>_bind_tools() -&gt; None\n</code></pre> <p>Called at the end of init to bind the tools to the model.</p> <p>This MUST be redefined in subclasses to dictate how the tools are bound to the model.</p> <p>Example: <pre><code># From OpenAIChatAgent\ndef _bind_tools(self) -&gt; None:\n    m_tools: List[ChatCompletionToolParam] = [\n        {\"type\": \"function\", \"function\": tool.description}\n        for tool in self.tools\n    ]\n\n    if len(m_tools) &gt; 0:\n        self.model.tools = m_tools\n</code></pre></p> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>def _bind_tools(self) -&gt; None:\n    \"\"\"\n    Called at the end of __init__ to bind the tools to the model.\n\n    This MUST be redefined in subclasses to dictate how\n    the tools are bound to the model.\n\n    Example:\n    ```python\n    # From OpenAIChatAgent\n    def _bind_tools(self) -&gt; None:\n        m_tools: List[ChatCompletionToolParam] = [\n            {\"type\": \"function\", \"function\": tool.description}\n            for tool in self.tools\n        ]\n\n        if len(m_tools) &gt; 0:\n            self.model.tools = m_tools\n    ```\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/templates/agent/#SilverLingua.core.templates.agent.Agent.add_tool","title":"add_tool","text":"<pre><code>add_tool(tool: Tool) -&gt; None\n</code></pre> <p>Adds a tool to the agent.</p> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>def add_tool(self, tool: Tool) -&gt; None:\n    \"\"\"\n    Adds a tool to the agent.\n    \"\"\"\n    self.tools.append(tool)\n    self._bind_tools()\n</code></pre>"},{"location":"api/core/templates/agent/#SilverLingua.core.templates.agent.Agent.add_tools","title":"add_tools","text":"<pre><code>add_tools(tools: List[Tool]) -&gt; None\n</code></pre> <p>Adds a list of tools to the agent.</p> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>def add_tools(self, tools: List[Tool]) -&gt; None:\n    \"\"\"\n    Adds a list of tools to the agent.\n    \"\"\"\n    self.tools.extend(tools)\n    self._bind_tools()\n</code></pre>"},{"location":"api/core/templates/agent/#SilverLingua.core.templates.agent.Agent.remove_tool","title":"remove_tool","text":"<pre><code>remove_tool(name: str) -&gt; None\n</code></pre> <p>Removes a tool from the agent.</p> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>def remove_tool(self, name: str) -&gt; None:\n    \"\"\"\n    Removes a tool from the agent.\n    \"\"\"\n    for i, tool in enumerate(self.tools):\n        if tool.name == name:\n            self.tools.pop(i)\n            break\n    self._bind_tools()\n</code></pre>"},{"location":"api/core/templates/agent/#SilverLingua.core.templates.agent.Agent._process_messages","title":"_process_messages","text":"<pre><code>_process_messages(messages: Messages) -&gt; List[Notion]\n</code></pre> <p>Convert various message types into a list of Notions.</p> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>def _process_messages(self, messages: Messages) -&gt; List[Notion]:\n    \"\"\"Convert various message types into a list of Notions.\"\"\"\n    if isinstance(messages, str):\n        return [Notion(content=messages, role=str(self.role.HUMAN.value))]\n    elif isinstance(messages, Notion):\n        return [messages]\n    elif isinstance(messages, Idearium):\n        return messages.notions\n    elif isinstance(messages, list):\n        return [\n            (\n                Notion(content=msg, role=str(self.role.HUMAN.value))\n                if isinstance(msg, str)\n                else msg\n            )\n            for msg in messages\n        ]\n    raise ValueError(f\"Unsupported message type: {type(messages)}\")\n</code></pre>"},{"location":"api/core/templates/agent/#SilverLingua.core.templates.agent.Agent._process_generation","title":"_process_generation","text":"<pre><code>_process_generation(responses: List[Notion], is_async=False) -&gt; List[Notion]\n</code></pre> <p>Wrapper around shared logic between generate and agenerate.</p> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>def _process_generation(\n    self, responses: List[Notion], is_async=False\n) -&gt; List[Notion]:\n    \"\"\"Wrapper around shared logic between generate and agenerate.\"\"\"\n    response = responses[0]\n    # logger.debug(f\"Response: {response}\")\n    if response.chat_role == ChatRole.TOOL_CALL:\n        # logger.debug(\"Tool call detected\")\n        # Add the tool call to the idearium\n        self.idearium.append(response)\n        # Call generate again with the tool response\n        tool_calls = ToolCalls.model_validate_json(\n            '{\"list\": ' + response.content + \"}\"\n        )\n        tool_response = self._use_tools(tool_calls)\n        # logger.debug(f\"Tool response: {tool_response}\")\n        if is_async:\n            return self.agenerate(tool_response)\n        else:\n            return self.generate(tool_response)\n    else:\n        return responses\n</code></pre>"},{"location":"api/core/templates/agent/#SilverLingua.core.templates.agent.Agent.generate","title":"generate","text":"<pre><code>generate(messages: Messages, **kwargs) -&gt; List[Notion]\n</code></pre> <p>Generates a response to the given messages by calling the underlying model's generate method and checking/actualizing tool usage.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>Union[str, Notion, Idearium, List[Union[str, Notion]]]</code> required <p>Returns:</p> Type Description <code>List[Notion]</code> <p>List[Notion]: A list of responses to the given messages. (Many times there will only be one response.)</p> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>def generate(self, messages: Messages, **kwargs) -&gt; List[Notion]:\n    \"\"\"\n    Generates a response to the given messages by calling the\n    underlying model's generate method and checking/actualizing tool usage.\n\n    Args:\n        messages (Union[str, Notion, Idearium, List[Union[str, Notion]]]):\n        The messages to respond to.\n\n    Returns:\n        List[Notion]: A list of responses to the given messages.\n            (Many times there will only be one response.)\n    \"\"\"\n    self.idearium.extend(self._process_messages(messages))\n    responses = self.model.generate(self.idearium, **kwargs)\n    result = self._process_generation(responses)\n\n    if self.auto_append_response:\n        self.idearium.extend(result)\n\n    return result\n</code></pre>"},{"location":"api/core/templates/agent/#SilverLingua.core.templates.agent.Agent.agenerate","title":"agenerate  <code>async</code>","text":"<pre><code>agenerate(messages: Messages, **kwargs) -&gt; List[Notion]\n</code></pre> <p>Asynchronously generates a response to the given messages by calling the underlying model's agenerate method and checking/actualizing tool usage.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>Union[str, Notion, Idearium, List[Union[str, Notion]]]</code> required <p>Returns:</p> Type Description <code>List[Notion]</code> <p>List[Notion]: A list of responses to the given messages. (Many times there will only be one response.)</p> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>async def agenerate(self, messages: Messages, **kwargs) -&gt; List[Notion]:\n    \"\"\"\n    Asynchronously generates a response to the given messages by calling the\n    underlying model's agenerate method and checking/actualizing tool usage.\n\n    Args:\n        messages (Union[str, Notion, Idearium, List[Union[str, Notion]]]):\n        The messages to respond to.\n\n    Returns:\n        List[Notion]: A list of responses to the given messages.\n            (Many times there will only be one response.)\n    \"\"\"\n    self.idearium.extend(self._process_messages(messages))\n    responses = await self.model.agenerate(self.idearium, **kwargs)\n    result = self._process_generation(responses, True)\n    r = await result if asyncio.iscoroutine(result) else result\n\n    if self.auto_append_response:\n        self.idearium.extend(r)\n\n    return r\n</code></pre>"},{"location":"api/core/templates/agent/#SilverLingua.core.templates.agent.Agent._process_tool_calls","title":"_process_tool_calls","text":"<pre><code>_process_tool_calls(tool_calls: ToolCalls)\n</code></pre> <p>Processes tool calls and returns the tool response.</p> <p>Parameters:</p> Name Type Description Default <code>tool_calls</code> <code>ToolCalls</code> <p>The tool calls to process.</p> required <p>Returns:</p> Type Description <p>Optional[ToolCalls]: The tool response. If None, no tool calls were found.</p> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>def _process_tool_calls(self, tool_calls: ToolCalls):\n    \"\"\"\n    Processes tool calls and returns the tool response.\n\n    Args:\n        tool_calls (ToolCalls): The tool calls to process.\n\n    Returns:\n        Optional[ToolCalls]: The tool response. If None, no tool calls were found.\n    \"\"\"\n    for i, tool_call in enumerate(tool_calls.list):\n        if not tool_call.id.startswith(\"call_\"):\n            # Something went wrong and this tool call is not valid\n            tool_calls.list.pop(i)\n            logger.error(\n                \"Invalid tool call: \"\n                + f\"{tool_call.model_dump_json(exclude_none=True)}\"\n            )\n\n    tc_dump = tool_calls.model_dump(exclude_none=True)\n    if tc_dump.get(\"list\"):\n        logger.debug(f\"Tool calls: {tc_dump}\")\n\n        # Create a new notion from the tool calls\n        tc_notion = Notion(\n            content=json.dumps(tc_dump.get(\"list\")),\n            role=str(ChatRole.TOOL_CALL.value),\n        )\n\n        # Add the tool call to the idearium\n        self.idearium.append(tc_notion)\n        # Call stream again with the tool response\n        tool_response = self._use_tools(tool_calls)\n        return tool_response\n    else:\n        logger.error(\"No tool calls found\")\n        return None\n</code></pre>"},{"location":"api/core/templates/agent/#SilverLingua.core.templates.agent.Agent.stream","title":"stream","text":"<pre><code>stream(messages: Messages, **kwargs)\n</code></pre> <p>Streams a response to the given prompt by calling the underlying model's stream method and checking/actualizing tool usage.</p> <p>NOTE: Will raise an exception if the underlying model does not support streaming.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>Union[str, Notion, Idearium, List[Union[str, Notion]]]</code> required <p>Returns:</p> Type Description <p>Generator[Notion, Any, None]: A generator of responses to the given messages.</p> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>def stream(self, messages: Messages, **kwargs):\n    \"\"\"\n    Streams a response to the given prompt by calling the\n    underlying model's stream method and checking/actualizing tool usage.\n\n    NOTE: Will raise an exception if the underlying model does not support\n    streaming.\n\n    Args:\n        messages (Union[str, Notion, Idearium, List[Union[str, Notion]]]):\n        The messages to respond to.\n\n    Returns:\n        Generator[Notion, Any, None]: A generator of responses to the given\n            messages.\n    \"\"\"\n    self.idearium.extend(self._process_messages(messages))\n    response_stream = self.model.stream(self.idearium, **kwargs)\n\n    # Process stream directly\n    tool_calls: Optional[ToolCalls] = None\n\n    for r in response_stream:\n        if r.chat_role == ChatRole.TOOL_CALL:\n            logger.debug(f\"Tool call detected: {r.content}\")\n            tc_chunks = ToolCalls.model_validate_json('{\"list\": ' + r.content + \"}\")\n            tool_calls = tool_calls and tool_calls.concat(tc_chunks) or tc_chunks\n            continue\n        elif r.content is not None:\n            logger.debug(f\"Got chunk in stream: {r.content!r}\")\n            if self.auto_append_response:\n                self.idearium.append(r)\n            yield r\n\n    # Handle tool calls if any\n    if tool_calls is not None:\n        logger.debug(\"Moving to tool response stream\")\n        tool_response = self._process_tool_calls(tool_calls)\n        if tool_response is not None:\n            for r in self.stream(tool_response):\n                yield r\n</code></pre>"},{"location":"api/core/templates/agent/#SilverLingua.core.templates.agent.Agent.astream","title":"astream  <code>async</code>","text":"<pre><code>astream(messages: Messages, **kwargs)\n</code></pre> <p>Asynchronously streams a response to the given prompt by calling the underlying model's astream method and checking/actualizing tool usage.</p> <p>NOTE: Will raise an exception if the underlying model does not support streaming.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>Union[str, Notion, Idearium, List[Union[str, Notion]]]</code> required <p>Returns:</p> Type Description <p>Generator[Notion, Any, None]: A generator of responses to the given messages.</p> Source code in <code>src/SilverLingua/core/templates/agent.py</code> <pre><code>async def astream(self, messages: Messages, **kwargs):\n    \"\"\"\n    Asynchronously streams a response to the given prompt by calling the\n    underlying model's astream method and checking/actualizing tool usage.\n\n    NOTE: Will raise an exception if the underlying model does not support\n    streaming.\n\n    Args:\n        messages (Union[str, Notion, Idearium, List[Union[str, Notion]]]):\n        The messages to respond to.\n\n    Returns:\n        Generator[Notion, Any, None]: A generator of responses to the given\n            messages.\n    \"\"\"\n    self.idearium.extend(self._process_messages(messages))\n    response_stream = self.model.astream(self.idearium, **kwargs)\n\n    # Process stream directly\n    tool_calls: Optional[ToolCalls] = None\n\n    async for r in response_stream:\n        if r.chat_role == ChatRole.TOOL_CALL:\n            logger.debug(f\"Tool call detected: {r.content}\")\n            tc_chunks = ToolCalls.model_validate_json('{\"list\": ' + r.content + \"}\")\n            tool_calls = tool_calls and tool_calls.concat(tc_chunks) or tc_chunks\n            continue\n        elif r.content is not None:\n            logger.debug(f\"Got chunk in astream: {r.content!r}\")\n            if self.auto_append_response:\n                self.idearium.append(r)\n            yield r\n\n    # Handle tool calls if any\n    if tool_calls is not None:\n        logger.debug(\"Moving to tool response stream\")\n        tool_response = self._process_tool_calls(tool_calls)\n        if tool_response is not None:\n            async for r in self.astream(tool_response):\n                yield r\n</code></pre>"},{"location":"api/core/templates/model/","title":"Model","text":""},{"location":"api/core/templates/model/#SilverLingua.core.templates.model","title":"model","text":""},{"location":"api/core/templates/model/#SilverLingua.core.templates.model.Messages","title":"Messages  <code>module-attribute</code>","text":"<pre><code>Messages = Union[str, Notion, Idearium, List[Union[str, Notion]]]\n</code></pre> <p>A type alias for the various types of messages that can be passed to a model.</p>"},{"location":"api/core/templates/model/#SilverLingua.core.templates.model.ModelType","title":"ModelType","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/core/templates/model/#SilverLingua.core.templates.model.ModelType.CHAT","title":"CHAT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CHAT = 0\n</code></pre>"},{"location":"api/core/templates/model/#SilverLingua.core.templates.model.ModelType.EMBEDDING","title":"EMBEDDING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBEDDING = 1\n</code></pre>"},{"location":"api/core/templates/model/#SilverLingua.core.templates.model.ModelType.CODE","title":"CODE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CODE = 2\n</code></pre>"},{"location":"api/core/templates/model/#SilverLingua.core.templates.model.Model","title":"Model","text":"<p>               Bases: <code>BaseModel</code>, <code>ABC</code></p> <p>Abstract class for all Large Language Models.</p> <p>This class outlines a standardized lifecycle for interacting with LLMs, aimed at ensuring a consistent process for message trimming, pre-processing, preparing requests for the model, invoking the model, standardizing the response, and post-processing. The lifecycle is as follows:</p> Lifecycle <ol> <li> <p>Pre-processing (<code>_preprocess</code>): Performs any necessary transformations or     adjustments to the messages prior to trimming or preparing them for model input.     (Optional)</p> </li> <li> <p>Preparing Request (<code>_format_request</code>): Converts the pre-processed messages     into a format suitable for model input.</p> </li> <li> <p>Model Invocation (<code>_call</code> or <code>_acall</code>): Feeds the prepared input to the LLM and     retrieves the raw model output. There should be both synchronous and     asynchronous versions available.</p> </li> <li> <p>Standardizing Response (<code>_standardize_response</code>): Transforms the raw model     output into a consistent response format suitable for further processing or     delivery.</p> </li> <li> <p>Post-processing (<code>_postprocess</code>): Performs any final transformations or     adjustments to the standardized responses, making them ready for delivery.     (Optional)</p> </li> </ol> <p>Subclasses should implement each of the non-optional lifecycle steps in accordance with the specific requirements and behaviors of the target LLM.</p> See also <ul> <li><code>Agent</code></li> <li><code>Idearium</code></li> <li><code>Notion</code></li> </ul>"},{"location":"api/core/templates/model/#SilverLingua.core.templates.model.Model.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(frozen=True)\n</code></pre>"},{"location":"api/core/templates/model/#SilverLingua.core.templates.model.Model.max_response","title":"max_response  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_response: int = Field(default=0)\n</code></pre>"},{"location":"api/core/templates/model/#SilverLingua.core.templates.model.Model.api_key","title":"api_key  <code>instance-attribute</code>","text":"<pre><code>api_key: str\n</code></pre>"},{"location":"api/core/templates/model/#SilverLingua.core.templates.model.Model.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/core/templates/model/#SilverLingua.core.templates.model.Model.role","title":"role  <code>instance-attribute</code>","text":"<pre><code>role: Type[ChatRole]\n</code></pre>"},{"location":"api/core/templates/model/#SilverLingua.core.templates.model.Model.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: ModelType\n</code></pre>"},{"location":"api/core/templates/model/#SilverLingua.core.templates.model.Model.llm","title":"llm  <code>instance-attribute</code>","text":"<pre><code>llm: Callable\n</code></pre>"},{"location":"api/core/templates/model/#SilverLingua.core.templates.model.Model.llm_async","title":"llm_async  <code>instance-attribute</code>","text":"<pre><code>llm_async: Callable\n</code></pre>"},{"location":"api/core/templates/model/#SilverLingua.core.templates.model.Model.can_stream","title":"can_stream  <code>instance-attribute</code>","text":"<pre><code>can_stream: bool\n</code></pre>"},{"location":"api/core/templates/model/#SilverLingua.core.templates.model.Model.tokenizer","title":"tokenizer  <code>instance-attribute</code>","text":"<pre><code>tokenizer: Tokenizer\n</code></pre>"},{"location":"api/core/templates/model/#SilverLingua.core.templates.model.Model.max_tokens","title":"max_tokens  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>max_tokens: int\n</code></pre> <p>The maximum number of tokens that can be fed to the model at once.</p>"},{"location":"api/core/templates/model/#SilverLingua.core.templates.model.Model._process_input","title":"_process_input","text":"<pre><code>_process_input(messages: Messages) -&gt; Idearium\n</code></pre> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>def _process_input(self, messages: Messages) -&gt; Idearium:\n    if isinstance(messages, str):\n        notions = [Notion(content=messages, role=self.role.HUMAN)]\n    elif isinstance(messages, Notion):\n        notions = [messages]\n    elif isinstance(messages, Idearium):\n        return messages  # Already an Idearium, no need to convert\n    elif isinstance(messages, list):\n        notions = [\n            (\n                Notion(content=msg, role=self.role.HUMAN)\n                if isinstance(msg, str)\n                else msg\n            )\n            for msg in messages\n        ]\n    else:\n        raise ValueError(\"Invalid input type for messages\")\n\n    return Idearium(self.tokenizer, self.max_tokens, notions)\n</code></pre>"},{"location":"api/core/templates/model/#SilverLingua.core.templates.model.Model._convert_role","title":"_convert_role","text":"<pre><code>_convert_role(role: ChatRole) -&gt; str\n</code></pre> <p>Converts the standard ChatRole to the model-specific role.</p> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>def _convert_role(self, role: ChatRole) -&gt; str:\n    \"\"\"\n    Converts the standard ChatRole to the model-specific role.\n    \"\"\"\n    return str(self.role[role.name].value)\n</code></pre>"},{"location":"api/core/templates/model/#SilverLingua.core.templates.model.Model._preprocess","title":"_preprocess","text":"<pre><code>_preprocess(messages: List[Notion]) -&gt; List[Notion]\n</code></pre> <p>Preprocesses the List of <code>Notions</code>, applying any effects necessary before being prepped for input into an API.</p> <p>This is a lifecycle method that is called by the <code>generate</code> method.</p> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>def _preprocess(self, messages: List[Notion]) -&gt; List[Notion]:\n    \"\"\"\n    Preprocesses the List of `Notions`, applying any effects necessary\n    before being prepped for input into an API.\n\n    This is a lifecycle method that is called by the `generate` method.\n    \"\"\"\n    return [\n        Notion(msg.content, self._convert_role(msg.chat_role), msg.persistent)\n        for msg in messages\n    ]\n</code></pre>"},{"location":"api/core/templates/model/#SilverLingua.core.templates.model.Model._format_request","title":"_format_request  <code>abstractmethod</code>","text":"<pre><code>_format_request(messages: List[Notion], *args, **kwargs) -&gt; Union[str, object]\n</code></pre> <p>Formats the List of <code>Notions</code> into a format suitable for model input.</p> <p>This is a lifecycle method that is called by the <code>generate</code> method.</p> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>@abstractmethod\ndef _format_request(\n    self, messages: List[Notion], *args, **kwargs\n) -&gt; Union[str, object]:\n    \"\"\"\n    Formats the List of `Notions` into a format suitable for model input.\n\n    This is a lifecycle method that is called by the `generate` method.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/templates/model/#SilverLingua.core.templates.model.Model._standardize_response","title":"_standardize_response  <code>abstractmethod</code>","text":"<pre><code>_standardize_response(response: Union[object, str, List[any]], *args, **kwargs) -&gt; List[Notion]\n</code></pre> <p>Standardizes the raw response from the model into a List of Notions.</p> <p>This is a lifecycle method that is called by the <code>generate</code> method.</p> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>@abstractmethod\ndef _standardize_response(\n    self, response: Union[object, str, List[any]], *args, **kwargs\n) -&gt; List[Notion]:\n    \"\"\"\n    Standardizes the raw response from the model into a List of Notions.\n\n    This is a lifecycle method that is called by the `generate` method.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/templates/model/#SilverLingua.core.templates.model.Model._postprocess","title":"_postprocess  <code>abstractmethod</code>","text":"<pre><code>_postprocess(response: List[Notion], *args, **kwargs) -&gt; List[Notion]\n</code></pre> <p>Postprocesses the response from the model, applying any final effects before being returned.</p> <p>This is a lifecycle method that is called by the <code>generate</code> method.</p> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>@abstractmethod\ndef _postprocess(self, response: List[Notion], *args, **kwargs) -&gt; List[Notion]:\n    \"\"\"\n    Postprocesses the response from the model, applying any final effects\n    before being returned.\n\n    This is a lifecycle method that is called by the `generate` method.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/templates/model/#SilverLingua.core.templates.model.Model._retry_call","title":"_retry_call  <code>abstractmethod</code>","text":"<pre><code>_retry_call(input: Union[str, object, List[any]], e: Exception, api_call: Callable, retries: int = 0) -&gt; Union[str, object]\n</code></pre> <p>Retry logic for API calls used by <code>_common_call_logic</code>.</p> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>@abstractmethod\ndef _retry_call(\n    self,\n    input: Union[str, object, List[any]],\n    e: Exception,\n    api_call: Callable,\n    retries: int = 0,\n) -&gt; Union[str, object]:\n    \"\"\"\n    Retry logic for API calls used by `_common_call_logic`.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/templates/model/#SilverLingua.core.templates.model.Model._common_call_logic","title":"_common_call_logic","text":"<pre><code>_common_call_logic(input: Union[str, object, List[any]], api_call: Callable, retries: int = 0) -&gt; Union[str, object]\n</code></pre> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>def _common_call_logic(\n    self,\n    input: Union[str, object, List[any]],\n    api_call: Callable,\n    retries: int = 0,\n) -&gt; Union[str, object]:\n    if input is None:\n        raise ValueError(\"No input provided.\")\n\n    try:\n        out = api_call(messages=input)\n        return out\n    except Exception as e:\n        logger.error(f\"Error calling LLM API: {e}\")\n        if retries &gt;= 3:\n            raise e\n\n        return self._retry_call(input, e, api_call, retries=retries)\n</code></pre>"},{"location":"api/core/templates/model/#SilverLingua.core.templates.model.Model._call","title":"_call","text":"<pre><code>_call(input: Union[str, object, List[any]], retries: int = 0, **kwargs) -&gt; object\n</code></pre> <p>Calls the model with the given input and returns the raw response.</p> <p>Should behave exactly as <code>_acall</code> does, but synchronously.</p> <p>This is a lifecycle method that is called by the <code>generate</code> method.</p> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>def _call(\n    self, input: Union[str, object, List[any]], retries: int = 0, **kwargs\n) -&gt; object:\n    \"\"\"\n    Calls the model with the given input and returns the raw response.\n\n    Should behave exactly as `_acall` does, but synchronously.\n\n    This is a lifecycle method that is called by the `generate` method.\n    \"\"\"\n\n    def api_call(**kwargs_):\n        return self.llm(**kwargs_, **kwargs)\n\n    return self._common_call_logic(input, api_call, retries)\n</code></pre>"},{"location":"api/core/templates/model/#SilverLingua.core.templates.model.Model._acall","title":"_acall  <code>async</code>","text":"<pre><code>_acall(input: Union[str, object, List[any]], retries: int = 0, **kwargs) -&gt; object\n</code></pre> <p>Calls the model with the given input and returns the raw response asynchronously.</p> <p>Should behave exactly as <code>_call</code> does, but asynchronously.</p> <p>This is a lifecycle method that is called by the <code>agenerate</code> method.</p> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>async def _acall(\n    self, input: Union[str, object, List[any]], retries: int = 0, **kwargs\n) -&gt; object:\n    \"\"\"\n    Calls the model with the given input and returns the\n    raw response asynchronously.\n\n    Should behave exactly as `_call` does, but asynchronously.\n\n    This is a lifecycle method that is called by the `agenerate` method.\n    \"\"\"\n\n    async def api_call(**kwargs_):\n        return await self.llm_async(**kwargs_, **kwargs)\n\n    result = self._common_call_logic(input, api_call, retries)\n    if asyncio.iscoroutine(result):\n        return await result\n    return result\n</code></pre>"},{"location":"api/core/templates/model/#SilverLingua.core.templates.model.Model._common_generate_logic","title":"_common_generate_logic","text":"<pre><code>_common_generate_logic(messages: Messages, is_async=False, **kwargs)\n</code></pre> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>def _common_generate_logic(\n    self,\n    messages: Messages,\n    is_async=False,\n    **kwargs,\n):\n    if messages is None:\n        raise ValueError(\"No messages provided.\")\n\n    call_method = self._acall if is_async else self._call\n\n    idearium = self._process_input(messages)\n    input = self._format_request(self._preprocess(idearium))\n\n    if is_async:\n\n        async def call():\n            response = await call_method(input, **kwargs)\n            output = self._standardize_response(response)\n            return self._postprocess(output)\n\n        return call()\n    else:\n        response = call_method(input, **kwargs)\n        output = self._standardize_response(response)\n        return self._postprocess(output)\n</code></pre>"},{"location":"api/core/templates/model/#SilverLingua.core.templates.model.Model.generate","title":"generate  <code>abstractmethod</code>","text":"<pre><code>generate(messages: Messages, *args, **kwargs) -&gt; List[Notion]\n</code></pre> <p>Calls the model with the given messages and returns the response.</p> <p>Messages can be any of: string, list of strings, Notion, list of Notions, or Idearium.</p> <p>This is the primary method for generating responses from the model, and is responsible for calling all of the lifecycle methods.</p> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>@abstractmethod\ndef generate(\n    self,\n    messages: Messages,\n    *args,\n    **kwargs,\n) -&gt; List[Notion]:\n    \"\"\"\n    Calls the model with the given messages and returns the response.\n\n    Messages can be any of:\n    string, list of strings, Notion, list of Notions, or Idearium.\n\n    This is the primary method for generating responses from the model,\n    and is responsible for calling all of the lifecycle methods.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/templates/model/#SilverLingua.core.templates.model.Model.agenerate","title":"agenerate  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>agenerate(messages: Messages, *args, **kwargs) -&gt; List[Notion]\n</code></pre> <p>Calls the model with the given messages and returns the response asynchronously.</p> <p>Messages can be any of: string, list of strings, Notion, list of Notions, or Idearium.</p> <p>This is the primary method for generating async responses from the model, and is responsible for calling all of the lifecycle methods.</p> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>@abstractmethod\nasync def agenerate(\n    self,\n    messages: Messages,\n    *args,\n    **kwargs,\n) -&gt; List[Notion]:\n    \"\"\"\n    Calls the model with the given messages and returns the response\n    asynchronously.\n\n    Messages can be any of:\n    string, list of strings, Notion, list of Notions, or Idearium.\n\n    This is the primary method for generating async responses from the model,\n    and is responsible for calling all of the lifecycle methods.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/templates/model/#SilverLingua.core.templates.model.Model._common_stream_logic","title":"_common_stream_logic","text":"<pre><code>_common_stream_logic(messages: Messages)\n</code></pre> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>def _common_stream_logic(self, messages: Messages):\n    if messages is None:\n        raise ValueError(\"No messages provided.\")\n\n    if not self.can_stream:\n        raise ValueError(\n            \"This model does not support streaming. \"\n            + \"Please use the `generate` method instead.\"\n        )\n\n    idearium = self._process_input(messages)\n    input = self._format_request(self._preprocess(idearium))\n    return input\n</code></pre>"},{"location":"api/core/templates/model/#SilverLingua.core.templates.model.Model.stream","title":"stream  <code>abstractmethod</code>","text":"<pre><code>stream(messages: Messages, *args, **kwargs) -&gt; Generator[Notion, Any, None]\n</code></pre> <p>Streams the model with the given messages and returns the response, one token at a time.</p> <p>Messages can be any of: string, list of strings, Notion, list of Notions, or Idearium.</p> <p>If the model cannot be streamed, this will raise an exception.</p> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>@abstractmethod\ndef stream(\n    self, messages: Messages, *args, **kwargs\n) -&gt; Generator[Notion, Any, None]:\n    \"\"\"\n    Streams the model with the given messages and returns the response,\n    one token at a time.\n\n    Messages can be any of:\n    string, list of strings, Notion, list of Notions, or Idearium.\n\n    If the model cannot be streamed, this will raise an exception.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/templates/model/#SilverLingua.core.templates.model.Model.astream","title":"astream  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>astream(messages: Messages, *args, **kwargs) -&gt; Generator[Notion, Any, None]\n</code></pre> <p>Streams the model with the given messages and returns the response, one token at a time, asynchronously.</p> <p>Messages can be any of: string, list of strings, Notion, list of Notions, or Idearium.</p> <p>If the model cannot be streamed, this will raise an exception.</p> Source code in <code>src/SilverLingua/core/templates/model.py</code> <pre><code>@abstractmethod\nasync def astream(\n    self, messages: Messages, *args, **kwargs\n) -&gt; Generator[Notion, Any, None]:\n    \"\"\"\n    Streams the model with the given messages and returns the response,\n    one token at a time, asynchronously.\n\n    Messages can be any of:\n    string, list of strings, Notion, list of Notions, or Idearium.\n\n    If the model cannot be streamed, this will raise an exception.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/modules/anthropic/","title":"Anthropic Provider","text":"<p>options: members: true show_root_heading: true show_source: true show_submodules: true</p>"},{"location":"api/modules/anthropic/#silverlingua_anthropic","title":"silverlingua_anthropic","text":"<p>The Anthropic module provides implementations of SilverLingua's core components using the Anthropic API.</p> <p>This module includes: - AnthropicChatAgent: An agent that uses Anthropic's chat completion API - AnthropicModel: A model that uses Anthropic's API - AnthropicChatRole: Role definitions for Anthropic's chat format</p>"},{"location":"api/modules/anthropic/#silverlingua_anthropic.AnthropicChatRole","title":"AnthropicChatRole  <code>module-attribute</code>","text":"<pre><code>AnthropicChatRole = create_chat_role('AnthropicChatRole', SYSTEM='system', HUMAN='user', AI='assistant', TOOL_CALL='assistant', TOOL_RESPONSE='tool')\n</code></pre>"},{"location":"api/modules/anthropic/#silverlingua_anthropic.anthropic_module","title":"anthropic_module  <code>module-attribute</code>","text":"<pre><code>anthropic_module = Module(name='Anthropic', description='Adds Anthropic models and agents.', version='1.0.0', tools=[], chat_roles=[AnthropicChatRole], react_roles=[])\n</code></pre>"},{"location":"api/modules/openai/","title":"OpenAI Provider","text":"<p>options: members: true show_root_heading: true show_source: true show_submodules: true</p>"},{"location":"api/modules/openai/#silverlingua_openai","title":"silverlingua_openai","text":"<p>The OpenAI module provides implementations of SilverLingua's core components using the OpenAI API.</p> <p>This module includes: - OpenAIChatAgent: An agent that uses OpenAI's chat completion API - OpenAIModel: A model that uses OpenAI's API - OpenAIChatRole: Role definitions for OpenAI's chat format</p>"},{"location":"api/modules/openai/#silverlingua_openai.OpenAIChatRole","title":"OpenAIChatRole  <code>module-attribute</code>","text":"<pre><code>OpenAIChatRole = create_chat_role('OpenAIChatRole', SYSTEM='system', HUMAN='user', AI='assistant', TOOL_CALL='assistant', TOOL_RESPONSE='tool')\n</code></pre>"},{"location":"api/modules/openai/#silverlingua_openai.openai_module","title":"openai_module  <code>module-attribute</code>","text":"<pre><code>openai_module = Module(name='OpenAI', description='Adds OpenAI models and agents.', version='1.0.0', tools=[], chat_roles=[OpenAIChatRole], react_roles=[])\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#using-pip","title":"Using pip","text":""},{"location":"getting-started/quickstart/","title":"Quickstart","text":""},{"location":"getting-started/quickstart/#basic-usage","title":"Basic Usage","text":""},{"location":"getting-started/quickstart/#openai-example","title":"OpenAI Example","text":""}]}